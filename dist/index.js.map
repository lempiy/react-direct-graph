{"version":3,"file":"index.js","sources":["../node_modules/tslib/tslib.es6.js","../src/core/node.interface.ts","../src/core/traverse-queue.class.ts","../src/core/matrix.class.ts","../src/core/graph-struct.class.ts","../src/core/graph-matrix.class.ts","../src/core/graph.class.ts","../node_modules/style-inject/dist/style-inject.es.js","../src/components/node-icon-default.tsx","../src/components/with-foreign-object.tsx","../src/components/element.tsx","../src/utils/index.ts","../src/components/marker-default.tsx","../src/components/polyline.tsx","../src/components/graph.tsx","../src/index.tsx"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\r\n * Types of nodes for internal usage\r\n */\r\nexport enum NodeType {\r\n    RootSimple = \"ROOT-SIMPLE\",\r\n    RootSplit = \"ROOT-SPLIT\",\r\n    Simple = \"SIMPLE\",\r\n    Split = \"SPLIT\",\r\n    Join = \"JOIN\",\r\n    SplitJoin = \"SPLIT-JOIN\"\r\n}\r\n/**\r\n * Types of anchors.\r\n * Join is anchor (vertex) between node and its join outcome:\r\n * N-J\r\n * N_|\r\n * N_|\r\n * Split is anchor (vertex) between node and its split income:\r\n * S-N\r\n * |_N\r\n * |_N\r\n */\r\nexport enum AnchorType {\r\n    Join = \"JOIN\",\r\n    Split = \"SPLIT\",\r\n    Loop = \"LOOP\"\r\n}\r\n\r\nexport enum AnchorMargin {\r\n    None = \"NONE\",\r\n    Left = \"LEFT\",\r\n    Right = \"RIGHT\"\r\n}\r\n\r\nexport interface INodeInput<T> {\r\n    /**\r\n     * Unique key for node. Duplicates are not allowed.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Outcomes of current node. Empty array if node is leaf.\r\n     */\r\n    next: string[];\r\n    /**\r\n     * Name of current node. Empty if the node without a name.\r\n     */\r\n    name?: string;\r\n    /**\r\n     * Name of current node. Empty if the node orientation is bottom.\r\n     */\r\n    nameOrientation?: \"bottom\" | \"top\";\r\n    /**\r\n     * Name of node edges. Matched to the edge index with the next. Empty array if the edges without a name.\r\n     */\r\n    edgeNames?: string[];\r\n    /**\r\n     * Payload data to transfer with current node events. Use whatever you want here.\r\n     */\r\n    payload: T;\r\n}\r\n\r\nexport interface INodeOutput<T> extends INodeInput<T> {\r\n    /**\r\n     * Defines whether or not node is pseudo-node - anchor.\r\n     * Which is used to draw split and join edges.\r\n     * @default false\r\n     */\r\n    isAnchor?: boolean;\r\n    /**\r\n     * Type of anchor. Only exists if isAnchor is true.\r\n     */\r\n    anchorType?: AnchorType;\r\n    /**\r\n     * Id if the anchor income. Only exists if isAnchor is true.\r\n     */\r\n    anchorFrom?: string;\r\n    /**\r\n     * Id if the anchor outcome. Only exists if isAnchor is true.\r\n     */\r\n    anchorTo?: string;\r\n    /**\r\n     * Anchor position inside cell over x axis.\r\n     */\r\n    anchorMargin?: AnchorMargin;\r\n    /**\r\n     * First level node incomes passed during traversal. Ignores join\r\n     * anchor. Mostly for tech usage. To recognize rendering parents\r\n     * Use renderIncomes.\r\n     */\r\n    passedIncomes: string[];\r\n    /**\r\n     * First level node incomes in rendering context. Can be used for\r\n     * backward travesal. Includes both types of anchors.\r\n     */\r\n    renderIncomes: string[];\r\n    /**\r\n     * Number of outcomes that already been placed on matrix\r\n     */\r\n    childrenOnMatrix: number;\r\n}\r\n\r\nexport interface IMatrixNode<T> extends INodeOutput<T> {\r\n    /**\r\n     * X coordinate of node\r\n     */\r\n    x: number;\r\n    /**\r\n     * Y coordinate of node\r\n     */\r\n    y: number;\r\n}\r\n","import { INodeOutput } from \"./node.interface\"\r\n\r\nexport interface IQueueItem<T> {\r\n    id: string\r\n    payload: T\r\n    next: string[]\r\n    name?: string\r\n    nameOrientation?: \"bottom\" | \"top\"\r\n    edgeNames?: string[]\r\n}\r\n\r\n/**\r\n * @class TraverseQueue\r\n * Special queue that is used for horizontal\r\n * graph traversing\r\n */\r\nexport class TraverseQueue<T> {\r\n    private _: INodeOutput<T>[] = [];\r\n    /**\r\n     * Add items to queue. If items already exist in this queue\r\n     * or bufferQueue do nothing but push new passed income to\r\n     * existing queue item\r\n     * @param incomeId income id for each element\r\n     * @param bufferQueue buffer queue to also check for duplicates\r\n     * @param items queue items to add\r\n     */\r\n    add(\r\n        incomeId: string | null,\r\n        bufferQueue: TraverseQueue<T> | null,\r\n        ...items: IQueueItem<T>[]\r\n    ) {\r\n        items.forEach(itm => {\r\n            const item =\r\n                this.find(item => item.id === itm.id) ||\r\n                (bufferQueue\r\n                    ? bufferQueue.find(item => item.id === itm.id)\r\n                    : null);\r\n            if (item && incomeId) {\r\n                item.passedIncomes.push(incomeId);\r\n                return\r\n            }\r\n            this._.push({\r\n                id: itm.id,\r\n                next: itm.next,\r\n                name: itm.name,\r\n                nameOrientation: itm.nameOrientation,\r\n                edgeNames: itm.edgeNames,\r\n                payload: itm.payload,\r\n                passedIncomes: incomeId ? [incomeId] : [],\r\n                renderIncomes: incomeId ? [incomeId] : [],\r\n                childrenOnMatrix: 0\r\n            })\r\n        })\r\n    }\r\n\r\n    find(cb: (item: INodeOutput<T>) => boolean): INodeOutput<T> | void {\r\n        return this._.find(cb)\r\n    }\r\n    /**\r\n     * Push item to queue. Skipping `add` method additional phases.\r\n     * @param item node item to add\r\n     */\r\n    push(item: INodeOutput<T>): void {\r\n        this._.push(item)\r\n    }\r\n    /**\r\n     * get current queue length\r\n     */\r\n    get length(): number {\r\n        return this._.length\r\n    }\r\n    /**\r\n     * @param cb callback with condition to check\r\n     * @returns true if at list one item satified condition in callback\r\n     */\r\n    some(cb: (item: INodeOutput<T>) => boolean): boolean {\r\n        return this._.some(cb)\r\n    }\r\n    /**\r\n     * Shift first element\r\n     * @returns first element from the queue\r\n     */\r\n    shift(): INodeOutput<T> | void {\r\n        return this._.shift()\r\n    }\r\n    /**\r\n     * Create new queue and extract of current\r\n     * elements of this queue new clone\r\n     * @returns newQueue new queue with items from old queue\r\n     */\r\n    drain(): TraverseQueue<T> {\r\n        const newQueue = new TraverseQueue<T>();\r\n        newQueue._ = newQueue._.concat(this._);\r\n        this._ = [];\r\n        return newQueue\r\n    }\r\n}\r\n","import { INodeOutput, IMatrixNode } from \"./node.interface\";\r\n\r\n/**\r\n * @class Matrix\r\n * Low level class used to compute 2D polar coordinates for each node\r\n * and anchor. Use this class if you want to skip D3 rendering in favor of\r\n * something else, for example, HTML or Canvas drawing.\r\n */\r\nexport class Matrix<T> {\r\n    private _: Array<Array<INodeOutput<T> | null>> = [];\r\n\r\n    /**\r\n     * Get with of matrix\r\n     */\r\n    get width(): number {\r\n        return this._.reduce((length, row) => (row.length > length ? row.length : length), 0) || 0;\r\n    }\r\n    /**\r\n     * Get height of matrix\r\n     */\r\n    get height(): number {\r\n        return this._.length;\r\n    }\r\n    /**\r\n     * Checks whether or not candidate point collides\r\n     * with present points by X vertex.\r\n     * @param point coordinates of point to check\r\n     */\r\n    hasHorizontalCollision([_, y]: number[]): boolean {\r\n        const row = this._[y];\r\n        if (!row) return false;\r\n        return row.some((point: INodeOutput<T> | null) => {\r\n            return !!point && !this.isAllChildrenOnMatrix(point);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks whether or not candidate point collides\r\n     * with present points by Y vertex.\r\n     * @param point coordinates of point to check\r\n     */\r\n    hasVerticalCollision([x, y]: number[]): boolean {\r\n        if (x >= this.width) {\r\n            return false;\r\n        }\r\n        return this._.some((row, index) => {\r\n            if (index < y) {\r\n                return false;\r\n            }\r\n            return !!row[x];\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if all next items of node already placed in matrix\r\n     */\r\n    private isAllChildrenOnMatrix(item: INodeOutput<T>) {\r\n        return item.next.length === item.childrenOnMatrix;\r\n    }\r\n\r\n    /**\r\n     * Inspects matrix by Y vertex from top to bottom to\r\n     * search first unused Y coordinate (row).\r\n     * If there no free row on the matrix it returns\r\n     * matrix height (Which is equal to first unused row,\r\n     * that currently not exist).\r\n     * @param x column coordinate to use for search\r\n     */\r\n    getFreeRowForColumn(x: number): number {\r\n        if (this.height === 0) return 0;\r\n        let y = this._.findIndex(row => {\r\n            return !row[x];\r\n        });\r\n        if (y === -1) {\r\n            y = this.height;\r\n        }\r\n        return y;\r\n    }\r\n    /**\r\n     * Extend matrix with empty rows\r\n     * @param toValue rows to add to matrix\r\n     */\r\n    private _extendHeight(toValue: number): void {\r\n        while (this.height < toValue) {\r\n            const row: Array<INodeOutput<T> | null> = [];\r\n            row.length = this.width;\r\n            row.fill(null);\r\n            this._.push(row);\r\n        }\r\n    }\r\n    /**\r\n     * Extend matrix with empty columns\r\n     * @param toValue columns to add to matrix\r\n     */\r\n    private _extendWidth(toValue: number): void {\r\n        this._.forEach(row => {\r\n            while (row.length < toValue) {\r\n                row.push(null);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Insert row before y\r\n     * @param y coordinate\r\n     */\r\n    insertRowBefore(y: number) {\r\n        const row: Array<INodeOutput<T> | null> = [];\r\n        row.length = this.width;\r\n        row.fill(null);\r\n        this._.splice(y, 0, row);\r\n    }\r\n    /**\r\n     * Insert column before x\r\n     * @param x coordinate\r\n     */\r\n    insertColumnBefore(x: number) {\r\n        this._.forEach(row => {\r\n            row.splice(x, 0, null);\r\n        });\r\n    }\r\n    /**\r\n     * Find x, y coordinate of first point item that\r\n     * satisfies condition defined in callback\r\n     * @param callback similar to [].find. Returns boolean\r\n     */\r\n    find(callback: (item: INodeOutput<T>) => boolean): number[] | null {\r\n        let result = null;\r\n        this._.forEach((row, y) => {\r\n            row.some((point, x) => {\r\n                if (!point) return false;\r\n                if (callback(point)) {\r\n                    result = [x, y];\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n        });\r\n        return result;\r\n    }\r\n    /**\r\n     * Find first node item that\r\n     * satisfies condition defined in callback\r\n     * @param callback similar to [].find. Returns boolean\r\n     */\r\n    findNode(callback: (item: INodeOutput<T>) => boolean): [number[], INodeOutput<T>] | null {\r\n        let result = null;\r\n        this._.forEach((row, y) => {\r\n            row.some((point, x) => {\r\n                if (!point) return false;\r\n                if (callback(point)) {\r\n                    result = [[x, y], point];\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n        });\r\n        return result;\r\n    }\r\n    /**\r\n     * Return point by x, y coordinate\r\n     */\r\n    getByCoords(x: number, y: number): INodeOutput<T> | null {\r\n        return this._[y][x];\r\n    }\r\n    /**\r\n     * Paste item to particular cell\r\n     * @param coords x and y coordinates for item\r\n     * @param item item to insert\r\n     */\r\n    insert([x, y]: number[], item: INodeOutput<T>) {\r\n        if (this.height <= y) {\r\n            this._extendHeight(y + 1);\r\n        }\r\n        if (this.width <= x) {\r\n            this._extendWidth(x + 1);\r\n        }\r\n\r\n        this._[y][x] = item;\r\n    }\r\n    /**\r\n     * @returns key value object where key is node id and\r\n     * value is node with its coordinates\r\n     */\r\n    normalize(): { [id: string]: IMatrixNode<T> } {\r\n        return this._.reduce((acc, row, y) => {\r\n            row.forEach((item, x) => {\r\n                if (!item) return;\r\n                acc[item.id] = { ...item, x, y };\r\n            });\r\n            return acc;\r\n        }, {});\r\n    }\r\n}\r\n","import { INodeInput, NodeType } from \"./node.interface\";\r\n\r\nconst isMultiple = (obj: { [id: string]: string[] }, id: string): boolean => obj[id] && obj[id].length > 1;\r\n\r\n/**\r\n * @class GraphStruct\r\n * Frame parent-class to simplify graph\r\n * elements recognition\r\n */\r\nexport class GraphStruct<T> {\r\n    protected _list: INodeInput<T>[] = [];\r\n    private _nodesMap: { [id: string]: INodeInput<T> } = {};\r\n    private _incomesByNodeIdMap: { [id: string]: string[] } = {};\r\n    private _outcomesByNodeIdMap: { [id: string]: string[] } = {};\r\n    private _loopsByNodeIdMap: { [id: string]: string[] } = {};\r\n    constructor(list: INodeInput<T>[]) {\r\n        this.applyList(list);\r\n    }\r\n    /**\r\n     * Fill graph with new nodes\r\n     * @param list input linked list of nodes\r\n     */\r\n    applyList(list: INodeInput<T>[]): void {\r\n        this._incomesByNodeIdMap = {};\r\n        this._outcomesByNodeIdMap = {};\r\n        this._nodesMap = {};\r\n        this._loopsByNodeIdMap = {};\r\n        this._list = list;\r\n        this._nodesMap = list.reduce((map, node) => {\r\n            if (map[node.id]) throw new Error(`Duplicate id ${node.id}`);\r\n            map[node.id] = node;\r\n            return map;\r\n        }, {});\r\n        this.detectIncomesAndOutcomes();\r\n    }\r\n    detectIncomesAndOutcomes() {\r\n        this._list.reduce((totalSet, node) => {\r\n            if (totalSet.has(node.id)) return totalSet;\r\n            return this.traverseVertically(node, new Set(), totalSet);\r\n        }, new Set<string>());\r\n    }\r\n    traverseVertically(node: INodeInput<T>, branchSet: Set<string>, totalSet: Set<string>): Set<string> {\r\n        if (branchSet.has(node.id)) throw new Error(`Duplicate incomes for node id ${node.id}`);\r\n        branchSet.add(node.id);\r\n        totalSet.add(node.id);\r\n        node.next.forEach(outcomeId => {\r\n            // skip loops which are already detected\r\n            if (this.isLoopEdge(node.id, outcomeId)) return;\r\n            // detect loops\r\n            if (branchSet.has(outcomeId)) {\r\n                this._loopsByNodeIdMap[node.id] = this._loopsByNodeIdMap[node.id]\r\n                    ? Array.from(new Set([...this._loopsByNodeIdMap[node.id], outcomeId]))\r\n                    : [outcomeId];\r\n                return;\r\n            }\r\n            this._incomesByNodeIdMap[outcomeId] = this._incomesByNodeIdMap[outcomeId]\r\n                ? Array.from(new Set([...this._incomesByNodeIdMap[outcomeId], node.id]))\r\n                : [node.id];\r\n            this._outcomesByNodeIdMap[node.id] = this._outcomesByNodeIdMap[node.id]\r\n                ? Array.from(new Set([...this._outcomesByNodeIdMap[node.id], outcomeId]))\r\n                : [outcomeId];\r\n            totalSet = this.traverseVertically(this._nodesMap[outcomeId], new Set(branchSet), totalSet);\r\n            return;\r\n        });\r\n\r\n        return totalSet;\r\n    }\r\n    /**\r\n     * Get graph roots.\r\n     * Roots is nodes without incomes\r\n     */\r\n    roots(): INodeInput<T>[] {\r\n        return this._list.filter(node => this.isRoot(node.id));\r\n    }\r\n    /**\r\n     * Get type of node\r\n     * @param id id of node\r\n     * @returns type of the node\r\n     */\r\n    protected nodeType(id: string): NodeType {\r\n        let nodeType = NodeType.Simple;\r\n        switch (true) {\r\n            case this.isRoot(id) && this.isSplit(id):\r\n                nodeType = NodeType.RootSplit;\r\n                break;\r\n            case this.isRoot(id):\r\n                nodeType = NodeType.RootSimple;\r\n                break;\r\n            case this.isSplit(id) && this.isJoin(id):\r\n                nodeType = NodeType.SplitJoin;\r\n                break;\r\n            case this.isSplit(id):\r\n                nodeType = NodeType.Split;\r\n                break;\r\n            case this.isJoin(id):\r\n                nodeType = NodeType.Join;\r\n                break;\r\n        }\r\n        return nodeType;\r\n    }\r\n    /**\r\n     * Whether or node is split\r\n     * @param id id of node\r\n     */\r\n    private isSplit(id: string): boolean {\r\n        return isMultiple(this._outcomesByNodeIdMap, id);\r\n    }\r\n    /**\r\n     * Whether or node is join\r\n     * @param id id of node\r\n     */\r\n    private isJoin(id: string): boolean {\r\n        return isMultiple(this._incomesByNodeIdMap, id);\r\n    }\r\n    /**\r\n     * Whether or node is root\r\n     * @param id id of node\r\n     */\r\n    private isRoot(id: string): boolean {\r\n        return !this._incomesByNodeIdMap[id] || !this._incomesByNodeIdMap[id].length;\r\n    }\r\n    protected isLoopEdge(nodeId: string, outcomeId: string): boolean {\r\n        return this._loopsByNodeIdMap[nodeId] && this._loopsByNodeIdMap[nodeId].includes(outcomeId);\r\n    }\r\n    /**\r\n     * Get loops of node by id\r\n     * @param id id of node\r\n     */\r\n    protected loops(id: string): string[] {\r\n        return this._loopsByNodeIdMap[id];\r\n    }\r\n    /**\r\n     * Get outcomes of node by id\r\n     * @param id id of node\r\n     */\r\n    protected outcomes(id: string): string[] {\r\n        return this._outcomesByNodeIdMap[id] || [];\r\n    }\r\n    /**\r\n     * Get incomes of node by id\r\n     * @param id id of node\r\n     */\r\n    protected incomes(id: string): string[] {\r\n        return this._incomesByNodeIdMap[id];\r\n    }\r\n    /**\r\n     * Get node by id\r\n     * @param id node id\r\n     */\r\n    protected node(id: string): INodeInput<T> {\r\n        return this._nodesMap[id];\r\n    }\r\n    /**\r\n     * get outcomes inputs helper\r\n     * @param itemId node id\r\n     */\r\n    protected getOutcomesArray(itemId: string): INodeInput<T>[] {\r\n        return this.outcomes(itemId).map(outcomeId => {\r\n            const out = this.node(outcomeId);\r\n            return {\r\n                id: out.id,\r\n                next: out.next,\r\n                name: out.name,\r\n                nameOrientation: out.nameOrientation,\r\n                edgeNames: out.edgeNames,\r\n                payload: out.payload\r\n            };\r\n        });\r\n    }\r\n}\r\n","import {AnchorMargin, AnchorType, INodeInput, INodeOutput} from \"./node.interface\";\r\nimport {TraverseQueue} from \"./traverse-queue.class\";\r\nimport {Matrix} from \"./matrix.class\";\r\nimport {GraphStruct} from \"./graph-struct.class\";\r\n\r\n/**\r\n * Holds iteration state of the graph\r\n */\r\ninterface State<T> {\r\n    mtx: Matrix<T>;\r\n    queue: TraverseQueue<T>;\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\ninterface LoopNode<T> {\r\n    id: string;\r\n    node: INodeOutput<T>;\r\n    coords: number[];\r\n    isSelfLoop?: boolean;\r\n}\r\n\r\n/**\r\n * @class GraphMatrix\r\n * Compute graph subclass used to interact with matrix\r\n */\r\nexport class GraphMatrix<T> extends GraphStruct<T> {\r\n    constructor(list: INodeInput<T>[]) {\r\n        super(list);\r\n    }\r\n    /**\r\n     * Check if item has unresolved incomes\r\n     * @param item item to check\r\n     */\r\n    protected _joinHasUnresolvedIncomes(item: INodeOutput<T>): boolean {\r\n        return item.passedIncomes.length != this.incomes(item.id).length;\r\n    }\r\n    /**\r\n     * Main insertion method - inserts item on matrix using state x and y\r\n     * or skips if it has collision on current row. Skipping is done\r\n     * by passing item back to the end of the queue\r\n     * @param item item to insert\r\n     * @param state state of current iteration\r\n     * @param checkCollision whether to check horizontal collision with existing point\r\n     * on 2D matrix\r\n     * @returns true if item was inserted false if skipped\r\n     */\r\n    private _insertOrSkipNodeOnMatrix(item: INodeOutput<T>, state: State<T>, checkCollision: boolean) {\r\n        const { mtx } = state;\r\n        // if point collides by x vertex, insert new row before y position\r\n        if (checkCollision && mtx.hasHorizontalCollision([state.x, state.y])) {\r\n            mtx.insertRowBefore(state.y);\r\n        }\r\n        mtx.insert([state.x, state.y], item);\r\n        this._markIncomesAsPassed(mtx, item);\r\n    }\r\n    /**\r\n     * Get all items incomes and find parent Y with the lowest\r\n     * Y coordinate on the matrix\r\n     * @param item target item\r\n     * @param mtx matrix to use as source\r\n     */\r\n    private _getLowestYAmongIncomes(item: INodeOutput<T>, mtx: Matrix<T>): number {\r\n        const incomes = item.passedIncomes;\r\n        if (incomes && incomes.length) {\r\n            // get lowest income y\r\n            const items = incomes.map(id => {\r\n                const coords = mtx.find(item => item.id === id);\r\n                if (!coords) throw new Error(`Cannot find coordinates for passed income: \"${id}\"`);\r\n                return coords[1];\r\n            });\r\n            return Math.min(...items);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Main processing nodes method.\r\n     * If node has incomes it finds lowest Y among them and\r\n     * sets state.y as lowest income Y value.\r\n     * Then inserts item on matrix using state x and y\r\n     * or skips if it has collision on current column. Skipping is done\r\n     * by passing item back to the end of the queue\r\n     * @param item item to insert\r\n     * @param state state of current iteration\r\n     * on 2D matrix\r\n     * @returns true if item was inserted false if skipped\r\n     */\r\n    protected _processOrSkipNodeOnMatrix(item: INodeOutput<T>, state: State<T>): boolean {\r\n        const { mtx, queue } = state;\r\n        if (item.passedIncomes && item.passedIncomes.length) {\r\n            state.y = this._getLowestYAmongIncomes(item, mtx);\r\n        }\r\n        const hasLoops = this.hasLoops(item);\r\n        const loopNodes = hasLoops ? this._handleLoopEdges(item, state) : null;\r\n        const needsLoopSkip = hasLoops && !loopNodes;\r\n        // if point collides by y vertex, skip it to next x\r\n        if (mtx.hasVerticalCollision([state.x, state.y]) || needsLoopSkip) {\r\n            queue.push(item);\r\n            return false;\r\n        }\r\n        this._insertOrSkipNodeOnMatrix(item, state, false);\r\n        if (loopNodes) {\r\n            this._insertLoopEdges(item, state, loopNodes);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private hasLoops(item: INodeOutput<T>): boolean {\r\n        return !!this.loops(item.id);\r\n    }\r\n\r\n    private _handleLoopEdges(item: INodeOutput<T>, state: State<T>): LoopNode<T>[] | null {\r\n        const { mtx } = state;\r\n        const loops = this.loops(item.id);\r\n        if (!loops) throw new Error(`No loops found for node ${item.id}`);\r\n        const loopNodes = loops.map(incomeId => {\r\n            if (item.id === incomeId) {\r\n                return {\r\n                    id: incomeId,\r\n                    node: item,\r\n                    coords: [state.x, state.y],\r\n                    isSelfLoop: true\r\n                };\r\n            }\r\n            const coords = mtx.find(n => n.id === incomeId);\r\n            if (!coords) throw new Error(`Loop target '${incomeId}' not found on matrix`);\r\n            const node = mtx.getByCoords(coords[0], coords[1]);\r\n            if (!node) throw new Error(`Loop target node'${incomeId}' not found on matrix`);\r\n            return {\r\n                id: incomeId,\r\n                node,\r\n                coords\r\n            };\r\n        });\r\n        const skip = loopNodes.some(income => {\r\n            const { coords } = income;\r\n            return mtx.hasVerticalCollision([state.x, coords[1] ? coords[1] - 1 : 0]);\r\n        });\r\n        if (skip) return null;\r\n        return loopNodes;\r\n    }\r\n\r\n    private _markIncomesAsPassed(mtx: Matrix<T>, item: INodeOutput<T>) {\r\n        item.renderIncomes.forEach(incomeId => {\r\n            const found = mtx.findNode(n => n.id === incomeId);\r\n            if (!found) throw new Error(`Income ${incomeId} is not on matrix yet`);\r\n            const [coords, income] = found;\r\n            income.childrenOnMatrix = Math.min(income.childrenOnMatrix + 1, income.next.length);\r\n            mtx.insert(coords, income);\r\n        });\r\n    }\r\n\r\n    protected _resolveCurrentJoinIncomes(mtx: Matrix<T>, join: INodeOutput<T>) {\r\n        this._markIncomesAsPassed(mtx, join);\r\n        join.renderIncomes = [];\r\n    }\r\n\r\n    private _insertLoopEdges(item: INodeOutput<T>, state: State<T>, loopNodes: LoopNode<T>[]): boolean {\r\n        const { mtx } = state;\r\n        const initialX = state.x;\r\n        let initialY = state.y;\r\n        loopNodes.forEach(income => {\r\n            const { id, coords, node } = income;\r\n            let renderIncomeId = item.id;\r\n            if (income.isSelfLoop) {\r\n                state.y = initialY;\r\n                state.x = initialX + 1;\r\n                const selfLoopId = `${id}-self`;\r\n                renderIncomeId = selfLoopId;\r\n                this._insertOrSkipNodeOnMatrix(\r\n                    {\r\n                        id: selfLoopId,\r\n                        anchorType: AnchorType.Loop,\r\n                        anchorMargin: AnchorMargin.Left,\r\n                        anchorFrom: item.id,\r\n                        anchorTo: id,\r\n                        isAnchor: true,\r\n                        renderIncomes: [node.id],\r\n                        passedIncomes: [item.id],\r\n                        payload: item.payload,\r\n                        next: [id],\r\n                        childrenOnMatrix: 0\r\n                    },\r\n                    state,\r\n                    false\r\n                );\r\n            }\r\n            state.y = coords[1];\r\n            const initialHeight = mtx.height;\r\n            const fromId = `${id}-${item.id}-from`;\r\n            const idTo = `${id}-${item.id}-to`;\r\n            node.renderIncomes = node.renderIncomes ? [...node.renderIncomes, fromId] : [fromId];\r\n            this._insertOrSkipNodeOnMatrix(\r\n                {\r\n                    id: idTo,\r\n                    anchorType: AnchorType.Loop,\r\n                    anchorMargin: AnchorMargin.Left,\r\n                    anchorFrom: item.id,\r\n                    anchorTo: id,\r\n                    isAnchor: true,\r\n                    renderIncomes: [renderIncomeId],\r\n                    passedIncomes: [item.id],\r\n                    payload: item.payload,\r\n                    next: [id],\r\n                    childrenOnMatrix: 0\r\n                },\r\n                state,\r\n                true\r\n            );\r\n            if (initialHeight !== mtx.height) initialY++;\r\n            state.x = coords[0];\r\n            this._insertOrSkipNodeOnMatrix(\r\n                {\r\n                    id: fromId,\r\n                    anchorType: AnchorType.Loop,\r\n                    anchorMargin: AnchorMargin.Right,\r\n                    anchorFrom: item.id,\r\n                    anchorTo: id,\r\n                    isAnchor: true,\r\n                    renderIncomes: [idTo],\r\n                    passedIncomes: [item.id],\r\n                    payload: item.payload,\r\n                    next: [id],\r\n                    childrenOnMatrix: 0\r\n                },\r\n                state,\r\n                false\r\n            );\r\n            state.x = initialX;\r\n        });\r\n        state.y = initialY;\r\n        return false;\r\n    }\r\n    /**\r\n     * Insert outcomes of split node\r\n     * @param item item to handle\r\n     * @param state current state of iteration\r\n     * @param levelQueue\r\n     */\r\n    protected _insertSplitOutcomes(item: INodeOutput<T>, state: State<T>, levelQueue: TraverseQueue<T>) {\r\n        const { queue } = state;\r\n        const outcomes = this.outcomes(item.id);\r\n        // first will be on the same y level as parent split\r\n        const firstOutcomeId = outcomes.shift();\r\n        if (!firstOutcomeId) throw new Error(`Split \"${item.id}\" has no outcomes`);\r\n        const first = this.node(firstOutcomeId);\r\n        queue.add(item.id, levelQueue, {\r\n            id: first.id,\r\n            next: first.next,\r\n            name: first.name,\r\n            nameOrientation: first.nameOrientation,\r\n            edgeNames: first.edgeNames,\r\n            payload: first.payload\r\n        });\r\n        // rest will create anchor with shift down by one\r\n        outcomes.forEach(outcomeId => {\r\n            state.y++;\r\n            const id = `${item.id}-${outcomeId}`;\r\n\r\n            this._insertOrSkipNodeOnMatrix(\r\n                {\r\n                    id: id,\r\n                    anchorType: AnchorType.Split,\r\n                    anchorMargin: AnchorMargin.Right,\r\n                    anchorFrom: item.id,\r\n                    anchorTo: outcomeId,\r\n                    isAnchor: true,\r\n                    renderIncomes: [item.id],\r\n                    passedIncomes: [item.id],\r\n                    payload: item.payload,\r\n                    next: [outcomeId],\r\n                    childrenOnMatrix: 0\r\n                },\r\n                state,\r\n                true\r\n            );\r\n            queue.add(id, levelQueue, { ...this.node(outcomeId) });\r\n        });\r\n    }\r\n    /**\r\n     * Insert incomes of join node\r\n     * @param item item to handle\r\n     * @param state current state of iteration\r\n     * @param levelQueue\r\n     * @param addItemToQueue\r\n     */\r\n    protected _insertJoinIncomes(\r\n        item: INodeOutput<T>,\r\n        state: State<T>,\r\n        levelQueue: TraverseQueue<T>,\r\n        addItemToQueue: boolean\r\n    ) {\r\n        const { mtx, queue } = state;\r\n        const incomes = item.passedIncomes;\r\n\r\n        const lowestY = this._getLowestYAmongIncomes(item, mtx);\r\n        incomes.forEach(incomeId => {\r\n            const found = mtx.findNode(n => n.id === incomeId);\r\n            if (!found) throw new Error(`Income ${incomeId} is not on matrix yet`);\r\n            const [[, y], income] = found;\r\n            if (lowestY === y) {\r\n                item.renderIncomes.push(incomeId);\r\n                income.childrenOnMatrix = Math.min(income.childrenOnMatrix + 1, income.next.length);\r\n                return;\r\n            }\r\n            state.y = y;\r\n            const id = `${incomeId}-${item.id}`;\r\n            item.renderIncomes.push(id);\r\n            this._insertOrSkipNodeOnMatrix(\r\n                {\r\n                    id: id,\r\n                    anchorType: AnchorType.Join,\r\n                    anchorMargin: AnchorMargin.Left,\r\n                    anchorFrom: incomeId,\r\n                    anchorTo: item.id,\r\n                    isAnchor: true,\r\n                    renderIncomes: [incomeId],\r\n                    passedIncomes: [incomeId],\r\n                    payload: item.payload,\r\n                    next: [item.id],\r\n                    childrenOnMatrix: 1 // if we're adding income - join is allready on matrix\r\n                },\r\n                state,\r\n                false\r\n            );\r\n        });\r\n        if (addItemToQueue) queue.add(item.id, levelQueue, ...this.getOutcomesArray(item.id));\r\n    }\r\n}\r\n","import { INodeInput, NodeType, INodeOutput } from \"./node.interface\";\r\nimport { TraverseQueue } from \"./traverse-queue.class\";\r\nimport { Matrix } from \"./matrix.class\";\r\nimport { GraphMatrix } from \"./graph-matrix.class\";\r\n\r\nconst MAX_ITERATIONS = 10000;\r\n\r\n/**\r\n * Holds iteration state of the graph\r\n */\r\ninterface State<T> {\r\n    mtx: Matrix<T>;\r\n    queue: TraverseQueue<T>;\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\n/**\r\n * @class Graph\r\n * Main iteration class used to transform\r\n * linked list of nodes to coordinate matrix\r\n */\r\nexport class Graph<T> extends GraphMatrix<T> {\r\n    constructor(list: INodeInput<T>[]) {\r\n        super(list);\r\n    }\r\n    /**\r\n     * Function to handle split nodes\r\n     * @param item item to handle\r\n     * @param state current state of iteration\r\n     * @param levelQueue buffer subqueue of iteration\r\n     */\r\n    private _handleSplitNode(\r\n        item: INodeOutput<T>,\r\n        state: State<T>,\r\n        levelQueue: TraverseQueue<T>\r\n    ) {\r\n        let isInserted = this._processOrSkipNodeOnMatrix(item, state);\r\n        if (isInserted) {\r\n            this._insertSplitOutcomes(item, state, levelQueue);\r\n        }\r\n    }\r\n    /**\r\n     * Function to handle splitjoin nodes\r\n     * @param item item to handle\r\n     * @param state current state of iteration\r\n     * @param levelQueue buffer subqueue of iteration\r\n     */\r\n    private _handleSplitJoinNode(\r\n        item: INodeOutput<T>,\r\n        state: State<T>,\r\n        levelQueue: TraverseQueue<T>\r\n    ): boolean {\r\n        const { queue, mtx } = state;\r\n        let isInserted = false;\r\n        if (this._joinHasUnresolvedIncomes(item)) {\r\n            queue.push(item);\r\n        } else {\r\n            this._resolveCurrentJoinIncomes(mtx, item);\r\n            isInserted = this._processOrSkipNodeOnMatrix(item, state);\r\n            if (isInserted) {\r\n                this._insertJoinIncomes(item, state, levelQueue, false);\r\n                this._insertSplitOutcomes(item, state, levelQueue);\r\n            }\r\n        }\r\n        return isInserted;\r\n    }\r\n    /**\r\n     * Function to handle join nodes\r\n     * @param item item to handle\r\n     * @param state current state of iteration\r\n     * @param levelQueue buffer subqueue of iteration\r\n     */\r\n    private _handleJoinNode(\r\n        item: INodeOutput<T>,\r\n        state: State<T>,\r\n        levelQueue: TraverseQueue<T>\r\n    ): boolean {\r\n        const { queue, mtx } = state;\r\n        let isInserted = false;\r\n        if (this._joinHasUnresolvedIncomes(item)) {\r\n            queue.push(item);\r\n        } else {\r\n            this._resolveCurrentJoinIncomes(mtx, item);\r\n            isInserted = this._processOrSkipNodeOnMatrix(item, state);\r\n            if (isInserted) {\r\n                this._insertJoinIncomes(item, state, levelQueue, true);\r\n            }\r\n        }\r\n        return isInserted;\r\n    }\r\n    /**\r\n     * Function to handle simple nodes\r\n     * @param item item to handle\r\n     * @param state current state of iteration\r\n     * @param levelQueue buffer subqueue of iteration\r\n     */\r\n    private _handleSimpleNode(\r\n        item: INodeOutput<T>,\r\n        state: State<T>,\r\n        levelQueue: TraverseQueue<T>\r\n    ): boolean {\r\n        const { queue } = state;\r\n        let isInserted = this._processOrSkipNodeOnMatrix(item, state);\r\n        if (isInserted) {\r\n            queue.add(item.id, levelQueue, ...this.getOutcomesArray(item.id));\r\n        }\r\n        return isInserted;\r\n    }\r\n    /**\r\n     * Method to handle single iteration item\r\n     * @param item queue item to process\r\n     * @param state state of iteration\r\n     * @param levelQueue\r\n     */\r\n    private _traverseItem(\r\n        item: INodeOutput<T>,\r\n        state: State<T>,\r\n        levelQueue: TraverseQueue<T>\r\n    ) {\r\n        const { mtx } = state;\r\n        switch (this.nodeType(item.id)) {\r\n            case NodeType.RootSimple:\r\n                // find free column and fallthrough\r\n                state.y = mtx.getFreeRowForColumn(0);\r\n            case NodeType.Simple:\r\n                this._handleSimpleNode(item, state, levelQueue);\r\n                break;\r\n            case NodeType.RootSplit:\r\n                // find free column and fallthrough\r\n                state.y = mtx.getFreeRowForColumn(0);\r\n            case NodeType.Split:\r\n                this._handleSplitNode(item, state, levelQueue);\r\n                break;\r\n            case NodeType.Join:\r\n                this._handleJoinNode(item, state, levelQueue);\r\n                break;\r\n            case NodeType.SplitJoin:\r\n                this._handleSplitJoinNode(item, state, levelQueue);\r\n                break;\r\n        }\r\n    }\r\n    /**\r\n     * Iterate over one level of graph\r\n     * starting from queue top item\r\n     */\r\n    private _traverseLevel(iterations: number, state: State<T>): number {\r\n        const { queue } = state;\r\n        const levelQueue = queue.drain();\r\n        while (levelQueue.length) {\r\n            iterations++;\r\n            const item = levelQueue.shift();\r\n            if (!item) throw new Error(\"Cannot shift from buffer queue\");\r\n            this._traverseItem(item, state, levelQueue);\r\n            if (iterations > MAX_ITERATIONS) {\r\n                throw new Error(`Infinite loop`);\r\n            }\r\n        }\r\n        return iterations;\r\n    }\r\n    /**\r\n     * Iterate over graph\r\n     * starting from queue root items\r\n     */\r\n    private _traverseList(state: State<T>): Matrix<T> {\r\n        let _safe = 0;\r\n        const { mtx, queue } = state;\r\n        while (queue.length) {\r\n            _safe = this._traverseLevel(_safe, state);\r\n            state.x++;\r\n        }\r\n        return mtx;\r\n    }\r\n    /**\r\n     * traverse main method to get coordinates matrix from graph\r\n     * @returns 2D matrix containing all nodes and anchors\r\n     */\r\n    traverse(): Matrix<T> {\r\n        const roots = this.roots();\r\n        const state: State<T> = {\r\n            mtx: new Matrix<T>(),\r\n            queue: new TraverseQueue(),\r\n            x: 0,\r\n            y: 0\r\n        };\r\n        if (!roots.length) {\r\n            if (this._list.length) throw new Error(`No roots in graph`);\r\n            return state.mtx;\r\n        }\r\n        const { mtx, queue } = state;\r\n        queue.add(\r\n            null,\r\n            null,\r\n            ...roots.map(r => ({\r\n                id: r.id,\r\n                next: r.next,\r\n                name: r.name,\r\n                nameOrientation: r.nameOrientation,\r\n                edgeNames: r.edgeNames,\r\n                payload: r.payload\r\n            }))\r\n        );\r\n        this._traverseList(state);\r\n        return mtx;\r\n    }\r\n}\r\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import { GraphNodeIconComponentProps } from \"./node-icon\";\r\nimport { INodeInput } from \"../core\";\r\nimport * as React from \"react\";\r\nimport styles from \"./node-icon-default.css\";\r\n\r\nexport class DefaultNodeIcon<T> extends React.Component<\r\n    GraphNodeIconComponentProps<T>\r\n> {\r\n    getClass(node: INodeInput<T>, incomes: INodeInput<T>[]): string {\r\n        if (incomes && incomes.length > 1 && node.next && node.next.length > 1)\r\n            return styles.nodePurple;\r\n        if (incomes && incomes.length > 1) return styles.nodeOrange;\r\n        if (node.next && node.next.length > 1) return styles.nodeGreen;\r\n        return styles.nodeBlue;\r\n    }\r\n    renderText(id: string) {\r\n        return (\r\n            <g>\r\n                <text\r\n                    strokeWidth=\"1\"\r\n                    x=\"0\"\r\n                    y=\"0\"\r\n                    dx=\"26\"\r\n                    dy=\"30\"\r\n                    textAnchor=\"middle\"\r\n                >\r\n                    {id}\r\n                </text>\r\n            </g>\r\n        );\r\n    }\r\n    render() {\r\n        const { node, incomes } = this.props;\r\n        return (\r\n            <svg\r\n                version=\"1.1\"\r\n                x=\"0px\"\r\n                y=\"0px\"\r\n                viewBox=\"0 0 52 52\"\r\n                className={styles.nodeDefaultIcon}\r\n            >\r\n                <g\r\n                    className={`node-icon-default ${\r\n                        styles.nodeDefaultIconGroup\r\n                    } ${this.getClass(node, incomes)}`}\r\n                >\r\n                    <path d=\"M40.824,52H11.176C5.003,52,0,46.997,0,40.824V11.176C0,5.003,5.003,0,11.176,0h29.649   C46.997,0,52,5.003,52,11.176v29.649C52,46.997,46.997,52,40.824,52z\" />\r\n                    {this.renderText(node.id)}\r\n                </g>\r\n            </svg>\r\n        );\r\n    }\r\n}\r\n","import * as React from \"react\"\r\n\r\ninterface WithForeignObjectProps {\r\n    width: number\r\n    height: number\r\n    x: number\r\n    y: number\r\n}\r\n\r\nexport const withForeignObject = <P extends Object>(\r\n    WrappedSVGComponent: React.ComponentType<P>\r\n): React.FC<P & WithForeignObjectProps> => ({\r\n    width,\r\n    height,\r\n    x,\r\n    y,\r\n    ...props\r\n}: WithForeignObjectProps) => (\r\n    <foreignObject\r\n        x={x}\r\n        y={y}\r\n        width={width}\r\n        height={height}\r\n        className={\"node-icon\"}\r\n    >\r\n        <WrappedSVGComponent {...props as P} />\r\n    </foreignObject>\r\n);\r\n","import * as React from \"react\";\r\nimport { IMatrixNode } from \"../core\";\r\nimport { GraphNodeIconComponentProps } from \"./node-icon\";\r\nimport { DefaultNodeIcon } from \"./node-icon-default\";\r\nimport { withForeignObject } from \"./with-foreign-object\";\r\nimport { GraphEventFunc, DataProps } from \"./element.types\";\r\n\r\nexport type ViewProps<T> = {\r\n    component?: React.ComponentType<GraphNodeIconComponentProps<T>>;\r\n    onNodeMouseEnter?: GraphEventFunc<T>;\r\n    onNodeMouseLeave?: GraphEventFunc<T>;\r\n    onNodeClick?: GraphEventFunc<T>;\r\n    cellSize: number;\r\n    padding: number;\r\n};\r\n\r\nexport class GraphElement<T> extends React.Component<\r\n    DataProps<T> & ViewProps<T>\r\n> {\r\n    getCoords(\r\n        cellSize: number,\r\n        padding: number,\r\n        node: IMatrixNode<T>\r\n    ): number[] {\r\n        return [node.x * cellSize + padding, node.y * cellSize + padding];\r\n    }\r\n\r\n    getSize(cellSize: number, padding: number): number {\r\n        return cellSize - padding * 2;\r\n    }\r\n\r\n    wrapEventHandler = (\r\n        cb: GraphEventFunc<T>,\r\n        node: IMatrixNode<T>,\r\n        incomes: IMatrixNode<T>[]\r\n    ): ((e: React.MouseEvent) => void) => {\r\n        return (e: React.MouseEvent) => cb(e, node, incomes);\r\n    };\r\n\r\n    diveToNodeIncome = (\r\n        node: IMatrixNode<T>,\r\n        nodesMap: { [id: string]: IMatrixNode<T> }\r\n    ): IMatrixNode<T> => {\r\n        if (!node.isAnchor) return node;\r\n        this.checkAnchorRenderIncomes(node);\r\n        return this.diveToNodeIncome(nodesMap[node.renderIncomes[0]], nodesMap);\r\n    };\r\n\r\n    checkAnchorRenderIncomes(node: IMatrixNode<T>) {\r\n        if (node.renderIncomes.length != 1)\r\n            throw new Error(\r\n                `Anchor has non 1 income: ${\r\n                    node.id\r\n                }. Incomes ${node.renderIncomes.join(\",\")}`\r\n            );\r\n    }\r\n\r\n    getNodeIncomes = (\r\n        node: IMatrixNode<T>,\r\n        nodesMap: { [id: string]: IMatrixNode<T> }\r\n    ): IMatrixNode<T>[] => {\r\n        return this.getAllIncomes(node, nodesMap).map(n =>\r\n            this.diveToNodeIncome(n, nodesMap)\r\n        );\r\n    };\r\n\r\n    getAllIncomes = (\r\n        node: IMatrixNode<T>,\r\n        nodesMap: { [id: string]: IMatrixNode<T> }\r\n    ): IMatrixNode<T>[] => node.renderIncomes.map(id => nodesMap[id]);\r\n\r\n    getNodeHandlers(): { [eventName: string]: (e: React.MouseEvent) => void } {\r\n        const {\r\n            node,\r\n            nodesMap,\r\n            onNodeClick,\r\n            onNodeMouseEnter,\r\n            onNodeMouseLeave\r\n        } = this.props;\r\n        const incomes = this.getNodeIncomes(node, nodesMap);\r\n        const handlers: {\r\n            [eventName: string]: (e: React.MouseEvent) => void;\r\n        } = {};\r\n        if (onNodeClick)\r\n            handlers.onClick = this.wrapEventHandler(\r\n                onNodeClick,\r\n                node,\r\n                incomes\r\n            );\r\n        if (onNodeMouseEnter)\r\n            handlers.onMouseEnter = this.wrapEventHandler(\r\n                onNodeMouseEnter,\r\n                node,\r\n                incomes\r\n            );\r\n        if (onNodeMouseLeave)\r\n            handlers.onMouseLeave = this.wrapEventHandler(\r\n                onNodeMouseLeave,\r\n                node,\r\n                incomes\r\n            );\r\n        return handlers;\r\n    }\r\n\r\n    renderNode() {\r\n        const { node, node: { isAnchor, name, nameOrientation = \"bottom\" }, nodesMap, cellSize, padding } = this.props;\r\n        const [x, y] = this.getCoords(cellSize, padding, node);\r\n        const size = this.getSize(cellSize, padding);\r\n        const NodeIcon = withForeignObject<GraphNodeIconComponentProps<T>>(\r\n            this.props.component ? this.props.component : DefaultNodeIcon\r\n        );\r\n        const incomes = this.getNodeIncomes(node, nodesMap);\r\n        const textY = nameOrientation === \"top\"\r\n            ? y - size * 0.2\r\n            : y + size * 1.2;\r\n        return (\r\n            !isAnchor && (\r\n                <g className=\"node-icon-group\" {...this.getNodeHandlers()}>\r\n                    <NodeIcon\r\n                        x={x}\r\n                        y={y}\r\n                        height={size}\r\n                        width={size}\r\n                        node={node}\r\n                        incomes={incomes}\r\n                    />\r\n                    {!!name && (\r\n                        <text\r\n                            x={x + size * 0.5}\r\n                            y={textY}\r\n                            textAnchor=\"middle\"\r\n                            dominantBaseline=\"middle\"\r\n                            style={{\r\n                                stroke: \"#fff\",\r\n                                strokeWidth: 3,\r\n                                fill: \"#2d578b\",\r\n                                paintOrder: \"stroke\"\r\n                            }}\r\n                        >\r\n                            {name}\r\n                        </text>\r\n                    )}\r\n                </g>\r\n            )\r\n        );\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <g\r\n                className=\"node-group\"\r\n                style={{\r\n                    strokeWidth: 2,\r\n                    fill: \"#ffffff\",\r\n                    stroke: \"#2d578b\"\r\n                }}\r\n            >\r\n                {this.renderNode()}\r\n            </g>\r\n        );\r\n    }\r\n}\r\n","import { AnchorMargin, INodeOutput } from \"../core\";\r\n\r\nexport enum VectorDirection {\r\n    Top = \"top\",\r\n    Bottom = \"bottom\",\r\n    Right = \"right\",\r\n    Left = \"left\"\r\n}\r\n\r\nconst getXVertexDirection = (x1: number, x2: number): VectorDirection => {\r\n    return x1 < x2 ? VectorDirection.Right : VectorDirection.Left;\r\n};\r\n\r\nconst getYVertexDirection = (y1: number, y2: number): VectorDirection => {\r\n    return y1 < y2 ? VectorDirection.Bottom : VectorDirection.Top;\r\n};\r\n\r\nexport const getEdgeMargins = <T>(\r\n    node: INodeOutput<T>,\r\n    income: INodeOutput<T>\r\n): AnchorMargin[] => {\r\n    let result = [AnchorMargin.None, AnchorMargin.None];\r\n    switch (true) {\r\n        case node.isAnchor && income.isAnchor:\r\n            result = [\r\n                node.anchorMargin as AnchorMargin,\r\n                income.anchorMargin as AnchorMargin\r\n            ];\r\n            break;\r\n        case node.isAnchor:\r\n            result = [\r\n                node.anchorMargin as AnchorMargin,\r\n                node.anchorMargin as AnchorMargin\r\n            ];\r\n            break;\r\n        case income.isAnchor:\r\n            result = [\r\n                income.anchorMargin as AnchorMargin,\r\n                income.anchorMargin as AnchorMargin\r\n            ];\r\n            break;\r\n    }\r\n    return result;\r\n};\r\n\r\nexport const getVectorDirection = (\r\n    x1: number,\r\n    y1: number,\r\n    x2: number,\r\n    y2: number\r\n): VectorDirection => {\r\n    return y1 === y2\r\n        ? getXVertexDirection(x1, x2)\r\n        : getYVertexDirection(y1, y2);\r\n};\r\n\r\nconst getMargin = (\r\n    margin: AnchorMargin,\r\n    padding: number,\r\n    cellSize: number\r\n): number => {\r\n    if (margin === AnchorMargin.None) return 0;\r\n    const size = Math.round((cellSize - padding * 2) * 0.15);\r\n    return margin === AnchorMargin.Left ? -size : size;\r\n};\r\n\r\nexport const getCellCenter = (\r\n    cellSize: number,\r\n    padding: number,\r\n    cellX: number,\r\n    cellY: number,\r\n    margin: AnchorMargin\r\n): number[] => {\r\n    const outset = getMargin(margin, padding, cellSize);\r\n    const x = cellX * cellSize + cellSize * 0.5 + outset;\r\n    const y = cellY * cellSize + cellSize * 0.5;\r\n    return [x, y];\r\n};\r\n\r\nexport const getCellEntry = (\r\n    direction: VectorDirection,\r\n    cellSize: number,\r\n    padding: number,\r\n    cellX: number,\r\n    cellY: number,\r\n    margin: AnchorMargin\r\n): number[] => {\r\n    switch (direction) {\r\n        case VectorDirection.Top:\r\n            var [x] = getCellCenter(cellSize, padding, cellX, cellY, margin);\r\n            var y = cellY * cellSize + padding;\r\n            return [x, y];\r\n        case VectorDirection.Bottom:\r\n            var [x] = getCellCenter(cellSize, padding, cellX, cellY, margin);\r\n            var y = cellY * cellSize + (cellSize - padding);\r\n            return [x, y];\r\n        case VectorDirection.Right:\r\n            var [, y] = getCellCenter(cellSize, padding, cellX, cellY, margin);\r\n            var x = cellX * cellSize + (cellSize - padding);\r\n            return [x, y];\r\n        case VectorDirection.Left:\r\n            var [, y] = getCellCenter(cellSize, padding, cellX, cellY, margin);\r\n            var x = cellX * cellSize + padding;\r\n            return [x, y];\r\n    }\r\n};\r\n\r\nfunction gen4(): string {\r\n    return Math.random()\r\n        .toString(16)\r\n        .slice(-4);\r\n}\r\n\r\nexport function uniqueId(prefix: string): string {\r\n    return (prefix || \"\").concat([gen4(), gen4(), gen4(), gen4()].join(\"-\"));\r\n}\r\n","import * as React from \"react\";\r\n\r\ntype Props = {\r\n    id: string;\r\n    width: number;\r\n    height: number;\r\n};\r\n\r\nexport class DefaultMarkerBody extends React.PureComponent {\r\n    render() {\r\n        return (\r\n            <defs>\r\n                <symbol id=\"markerPoly\">\r\n                    <polyline\r\n                        stroke=\"none\"\r\n                        points={\"0,0 20,9 20,11 0,20 5,10\"}\r\n                    />\r\n                </symbol>\r\n            </defs>\r\n        );\r\n    }\r\n}\r\n\r\nexport class DefaultMarker extends React.PureComponent<Props> {\r\n    render() {\r\n        const { id, width, height } = this.props;\r\n        return (\r\n            <marker\r\n                id={id}\r\n                viewBox={`0 0 20 20`}\r\n                refX={20}\r\n                refY={10}\r\n                markerUnits=\"userSpaceOnUse\"\r\n                orient=\"auto\"\r\n                markerWidth={width}\r\n                markerHeight={height}\r\n            >\r\n                <use xlinkHref=\"#markerPoly\" />\r\n            </marker>\r\n        );\r\n    }\r\n}\r\n","import * as React from \"react\";\nimport { IMatrixNode, AnchorMargin } from \"../core\";\nimport {\n    VectorDirection,\n    getVectorDirection,\n    getEdgeMargins,\n    getCellCenter,\n    getCellEntry,\n    uniqueId\n} from \"../utils\";\nimport { GraphEventFunc, DataProps } from \"./element.types\";\nimport { DefaultMarker } from \"./marker-default\";\n\nexport type ViewProps<T> = {\n    edgeComponent?: React.ComponentType<T>;\n    onEdgeMouseEnter?: GraphEventFunc<T>;\n    onEdgeMouseLeave?: GraphEventFunc<T>;\n    onEdgeClick?: GraphEventFunc<T>;\n    cellSize: number;\n    padding: number;\n};\n\ninterface LineBranch<T> {\n    node: IMatrixNode<T>;\n    income: IMatrixNode<T>;\n    line: number[][];\n}\n\nfunction getPointWithResolver<T>(\n    direction: VectorDirection,\n    cellSize: number,\n    padding: number,\n    item: IMatrixNode<T>,\n    margin: AnchorMargin\n): number[] {\n    let x1, y1;\n    if (item.isAnchor) {\n        [x1, y1] = getCellCenter(cellSize, padding, item.x, item.y, margin);\n    } else {\n        [x1, y1] = getCellEntry(\n            direction,\n            cellSize,\n            padding,\n            item.x,\n            item.y,\n            margin\n        );\n    }\n    return [x1, y1];\n}\n\nconst pointResolversMap: { [key in VectorDirection]: VectorDirection[] } = {\n    [VectorDirection.Top]: [VectorDirection.Top, VectorDirection.Bottom],\n    [VectorDirection.Bottom]: [VectorDirection.Bottom, VectorDirection.Top],\n    [VectorDirection.Right]: [VectorDirection.Right, VectorDirection.Left],\n    [VectorDirection.Left]: [VectorDirection.Left, VectorDirection.Right]\n};\n\nexport class GraphPolyline<T> extends React.Component<\n    DataProps<T> & ViewProps<T>\n> {\n    getPolyline(\n        cellSize: number,\n        padding: number,\n        branch: IMatrixNode<T>[]\n    ): number[][] {\n        return branch\n            .filter((_, i) => {\n                return i + 1 !== branch.length;\n            })\n            .reduce((result: number[][], node, i) => {\n                const nextNode = branch[i + 1];\n                const line = this.getLineToIncome(\n                    cellSize,\n                    padding,\n                    node,\n                    nextNode\n                );\n                const [x1, y1, x2, y2] = line.line;\n                if (i === 0) {\n                    result.push([x1, y1], [x2, y2]);\n                } else {\n                    result.push([x2, y2]);\n                }\n                return result;\n            }, []);\n    }\n    getLineToIncome(\n        cellSize: number,\n        padding: number,\n        node: IMatrixNode<T>,\n        income: IMatrixNode<T>\n    ) {\n        const margins = getEdgeMargins(node, income);\n        const direction = getVectorDirection(\n            node.x,\n            node.y,\n            income.x,\n            income.y\n        );\n        const [from, to] = pointResolversMap[direction];\n        const [nodeMargin, incomeMargin] = margins;\n        const [x1, y1] = getPointWithResolver(\n            from,\n            cellSize,\n            padding,\n            node,\n            nodeMargin\n        );\n        const [x2, y2] = getPointWithResolver(\n            to,\n            cellSize,\n            padding,\n            income,\n            incomeMargin\n        );\n        return {\n            node,\n            income,\n            line: [x1, y1, x2, y2]\n        };\n    }\n\n    getLines(\n        cellSize: number,\n        padding: number,\n        node: IMatrixNode<T>,\n        nodesMap: { [id: string]: IMatrixNode<T> }\n    ): LineBranch<T>[] {\n        const branches = this.getNodeBranches(node, nodesMap);\n        return branches.map(branch => ({\n            node: node,\n            income: branch[branch.length - 1],\n            line: this.getPolyline(cellSize, padding, branch)\n        }));\n    }\n\n    getCoords(\n        cellSize: number,\n        padding: number,\n        node: IMatrixNode<T>\n    ): number[] {\n        return [node.x * cellSize + padding, node.y * cellSize + padding];\n    }\n\n    getSize(cellSize: number, padding: number): number {\n        return cellSize - padding * 2;\n    }\n\n    wrapEventHandler = (\n        cb: GraphEventFunc<T>,\n        node: IMatrixNode<T>,\n        incomes: IMatrixNode<T>[]\n    ): ((e: React.MouseEvent) => void) => {\n        return (e: React.MouseEvent) => cb(e, node, incomes);\n    };\n\n    diveToNodeIncome = (\n        node: IMatrixNode<T>,\n        nodesMap: { [id: string]: IMatrixNode<T> }\n    ): IMatrixNode<T> => {\n        if (!node.isAnchor) return node;\n        this.checkAnchorRenderIncomes(node);\n        return this.diveToNodeIncome(nodesMap[node.renderIncomes[0]], nodesMap);\n    };\n\n    getNodeBranches = (\n        node: IMatrixNode<T>,\n        nodesMap: { [id: string]: IMatrixNode<T> }\n    ): IMatrixNode<T>[][] => {\n        return this.getAllIncomes(node, nodesMap).map(n => [\n            node,\n            ...this.getIncomeBranch(n, nodesMap)\n        ]);\n    };\n\n    getIncomeBranch = (\n        lastIncome: IMatrixNode<T>,\n        nodesMap: { [id: string]: IMatrixNode<T> }\n    ): IMatrixNode<T>[] => {\n        const branch: IMatrixNode<T>[] = [];\n        while (lastIncome.isAnchor) {\n            this.checkAnchorRenderIncomes(lastIncome);\n            branch.push(lastIncome);\n            lastIncome = nodesMap[lastIncome.renderIncomes[0]];\n        }\n        branch.push(lastIncome);\n        return branch;\n    };\n\n    checkAnchorRenderIncomes(node: IMatrixNode<T>) {\n        if (node.renderIncomes.length != 1)\n            throw new Error(\n                `Anchor has non 1 income: ${\n                    node.id\n                }. Incomes ${node.renderIncomes.join(\",\")}`\n            );\n    }\n\n    getAllIncomes = (\n        node: IMatrixNode<T>,\n        nodesMap: { [id: string]: IMatrixNode<T> }\n    ): IMatrixNode<T>[] => node.renderIncomes.map(id => nodesMap[id]);\n\n    getLineHandlers(\n        node: IMatrixNode<T>,\n        income: IMatrixNode<T>\n    ): { [eventName: string]: (e: React.MouseEvent) => void } {\n        const { onEdgeClick, onEdgeMouseEnter, onEdgeMouseLeave } = this.props;\n        const handlers: {\n            [eventName: string]: (e: React.MouseEvent) => void;\n        } = {};\n        if (onEdgeClick)\n            handlers.onClick = this.wrapEventHandler(onEdgeClick, node, [\n                income\n            ]);\n        if (onEdgeMouseEnter)\n            handlers.onMouseEnter = this.wrapEventHandler(\n                onEdgeMouseEnter,\n                node,\n                [income]\n            );\n        if (onEdgeMouseLeave)\n            handlers.onMouseLeave = this.wrapEventHandler(\n                onEdgeMouseLeave,\n                node,\n                [income]\n            );\n        return handlers;\n    }\n\n    getMarker(markerHash: string, incomeId: string): { [key: string]: string } {\n        const markerId = this.getMarkerId(markerHash, incomeId);\n        return markerId ? { markerEnd: `url(#${markerId})` } : {};\n    }\n\n    getMarkerId(markerHash: string, incomeId: string): string {\n        const { node } = this.props;\n        return `${markerHash}-${node.id.trim()}-${incomeId.trim()}`;\n    }\n\n    getLineNameCoords(income: IMatrixNode<T>): number[] {\n        const { node, node: {id}, cellSize, padding } = this.props;\n        const index = income.next.findIndex(uuid => uuid === id);\n\n        const [, nodeY] = this.getCoords(cellSize, padding, node);\n        const [x, incomeY] = this.getCoords(cellSize, padding, income);\n\n        let y = nodeY;\n        if (incomeY > nodeY) {\n            y = incomeY;\n        }\n        if (incomeY === nodeY) {\n            y = y + cellSize * index;\n        }\n\n        return [x, y];\n    };\n\n    getLineComponentCoords(income: IMatrixNode<T>): number[] {\n        const { node, node: {id}, cellSize, padding } = this.props;\n        const index = income.next.findIndex(uuid => uuid === id);\n\n        const [nodeX, nodeY] = this.getCoords(cellSize, padding, node);\n        const [incomeX, incomeY] = this.getCoords(cellSize, padding, income);\n\n        const x = incomeX/2 + nodeX/2;\n\n        let y = nodeY;\n        if (incomeY > nodeY) {\n            y = incomeY;\n        }\n        if (incomeY === nodeY) {\n            y = y + cellSize * index;\n        }\n\n        return [x, y];\n    };\n\n    lineComponent(income: IMatrixNode<T>) {\n        const { cellSize, padding, edgeComponent } = this.props;\n        const [x, y] = this.getLineComponentCoords(income);\n        const size = this.getSize(cellSize, padding);\n\n        if (!edgeComponent) {\n            return null;\n        }\n\n        const Component = edgeComponent;\n        return (\n            <foreignObject\n                className=\"edge-icon\"\n                x={x + size * 0.5 - cellSize * 0.1}\n                y={y + size * 0.5 - cellSize * 0.1}\n                width={cellSize * 0.2}\n                height={cellSize * 0.2}\n                style={{ display: \"none\" }}\n            >\n                <Component />\n            </foreignObject>\n        );\n    }\n\n    lineName(income: IMatrixNode<T>) {\n        const { node: {id}, cellSize, padding } = this.props;\n        const { next, edgeNames = [] } = income;\n\n        const [nameX, nameY] = this.getLineNameCoords(income);\n        const [circleX, circleY] = this.getLineComponentCoords(income);\n        const size = this.getSize(cellSize, padding);\n        const index = next.findIndex(uuid => uuid === id);\n        return (\n            <>\n                <circle\n                    cx={circleX + size * 0.5}\n                    cy={circleY + size * 0.5}\n                    r={cellSize * 0.15}\n                    style={{\n                        stroke: \"none\",\n                        fill: \"fff\",\n                        opacity: 0.01\n                    }}\n                />\n                {!!edgeNames[index] && (\n                    <text\n                        x={nameX + size * 1.5}\n                        y={nameY + size * 0.3}\n                        textAnchor=\"middle\"\n                        dominantBaseline=\"middle\"\n                        style={{\n                            stroke: \"#fff\",\n                            strokeWidth: 3,\n                            fill: \"#2d578b\",\n                            paintOrder: \"stroke\"\n                        }}\n                    >\n                        {edgeNames[index]}\n                    </text>\n                )}\n            </>\n        )\n    }\n\n    getLinePoints(line: LineBranch<T>): string {\n        return line.line\n            .map(point => point.join(\",\"))\n            .reverse()\n            .join(\" \");\n    }\n\n    renderLines(node: IMatrixNode<T>, lines: LineBranch<T>[]) {\n        const markerHash = uniqueId(\"marker-\");\n        return lines.map(line => (\n            <g\n                key={`line-${node.id}-${line.income.id}`}\n                {...this.getLineHandlers(line.node, line.income)}\n                style={{\n                    strokeWidth: 2,\n                    fill: \"#2d578b\",\n                    stroke: \"#2d578b\"\n                }}\n            >\n                {this.lineName(line.income)}\n                <DefaultMarker\n                    id={this.getMarkerId(markerHash, line.income.id)}\n                    width={12}\n                    height={12}\n                />\n                <polyline\n                    fill={\"none\"}\n                    className=\"node-line\"\n                    points={this.getLinePoints(line)}\n                    style={{\n                        strokeWidth: 6,\n                        stroke: \"#ffffff\"\n                    }}\n                />\n                <polyline\n                    {...this.getMarker(markerHash, line.income.id)}\n                    fill={\"none\"}\n                    className=\"node-line\"\n                    points={this.getLinePoints(line)}\n                />\n                {this.lineComponent(line.income)}\n            </g>\n        ));\n    }\n\n    render() {\n        const { node, nodesMap, cellSize, padding } = this.props;\n        const lines = this.getLines(cellSize, padding, node, nodesMap);\n        return (\n            lines.length && (\n                <g className=\"line-group\">{this.renderLines(node, lines)}</g>\n            )\n        );\n    }\n}\n","import * as React from \"react\";\r\nimport { IMatrixNode } from \"../core\";\r\nimport { GraphElement, ViewProps as ElementViewProps } from \"./element\";\r\nimport { GraphPolyline, ViewProps as PolylineViewProps } from \"./polyline\";\r\nimport { DefaultMarkerBody } from \"./marker-default\";\r\n\r\nexport type Props<T> = {\r\n    nodesMap: { [id: string]: IMatrixNode<T> };\r\n    cellSize: number;\r\n    padding: number;\r\n    widthInCells: number;\r\n    heightInCells: number;\r\n};\r\n\r\nexport type ViewProps<T> = ElementViewProps<T> & PolylineViewProps<T>;\r\n\r\ninterface INodeElementInput<T> {\r\n    node: IMatrixNode<T>;\r\n}\r\n\r\nexport class Graph<T> extends React.Component<ViewProps<T> & Props<T>> {\r\n    getNodeElementInputs = (nodesMap: { [id: string]: IMatrixNode<T> }): INodeElementInput<T>[] => {\r\n        return Object.entries(nodesMap)\r\n            .filter(([_, node]) => !node.isAnchor)\r\n            .map(([_, node]) => ({\r\n                node\r\n            }));\r\n    };\r\n    renderElements() {\r\n        const { nodesMap, cellSize, padding, widthInCells, heightInCells, ...restProps } = this.props;\r\n        const elements = this.getNodeElementInputs(nodesMap);\r\n        return (\r\n            <>\r\n                {elements.map(props => (\r\n                    <GraphPolyline\r\n                        key={`polyline__${props.node.id}`}\r\n                        cellSize={cellSize}\r\n                        padding={padding}\r\n                        nodesMap={nodesMap}\r\n                        {...props}\r\n                        {...restProps}\r\n                    />\r\n                ))}\r\n                {elements.map(props => (\r\n                    <GraphElement\r\n                        key={`element__${props.node.id}`}\r\n                        cellSize={cellSize}\r\n                        padding={padding}\r\n                        nodesMap={nodesMap}\r\n                        {...props}\r\n                        {...restProps}\r\n                    />\r\n                ))}\r\n            </>\r\n        )\r\n    }\r\n    render() {\r\n        const { cellSize, widthInCells, heightInCells } = this.props;\r\n        return (\r\n            <svg\r\n                xmlns=\"http://www.w3.org/2000/svg\"\r\n                xmlnsXlink=\"http://www.w3.org/1999/xlink\"\r\n                version=\"1\"\r\n                width={widthInCells * cellSize}\r\n                height={heightInCells * cellSize}\r\n            >\r\n                <DefaultMarkerBody />\r\n                {this.renderElements()}\r\n            </svg>\r\n        );\r\n    }\r\n}\r\n","/**\r\n * @class DirectGraph\r\n */\r\n\r\nimport * as React from \"react\";\r\nimport { INodeInput, IMatrixNode, Graph } from \"./core\";\r\nimport { Graph as GraphView, ViewProps } from \"./components\";\r\n\r\ntype Props<T> = {\r\n    list: INodeInput<T>[];\r\n    cellSize: number;\r\n    padding: number;\r\n};\r\n\r\nexport { INodeInput, IMatrixNode } from \"./core\";\r\nexport type GraphProps<T> = Props<T> & ViewProps<T>;\r\n\r\ntype GraphViewData<T> = {\r\n    nodesMap: { [id: string]: IMatrixNode<T> };\r\n    widthInCells: number;\r\n    heightInCells: number;\r\n};\r\n\r\nexport default class DirectGraph<T> extends React.Component<GraphProps<T>> {\r\n    getNodesMap = (list: INodeInput<T>[]): GraphViewData<T> => {\r\n        const graph = new Graph(list);\r\n        const mtx = graph.traverse();\r\n        return {\r\n            nodesMap: mtx.normalize(),\r\n            widthInCells: mtx.width,\r\n            heightInCells: mtx.height\r\n        };\r\n    };\r\n\r\n    render() {\r\n        const { list, ...viewProps } = this.props;\r\n        const dataProps = this.getNodesMap(list);\r\n\r\n        return <GraphView {...dataProps} {...viewProps} />;\r\n    }\r\n}\r\n"],"names":["tslib_1.__extends","React.createElement","React.Component","React.PureComponent","GraphView"],"mappings":";;;;;;AAAA;;;;;;;;;;;;;;;;AAgBA,IAAI,aAAa,GAAG,SAAS,CAAC,EAAE,CAAC,EAAE;IAC/B,aAAa,GAAG,MAAM,CAAC,cAAc;SAChC,EAAE,SAAS,EAAE,EAAE,EAAE,YAAY,KAAK,IAAI,UAAU,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,SAAS,GAAG,CAAC,CAAC,EAAE,CAAC;QAC5E,UAAU,CAAC,EAAE,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IAC/E,OAAO,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;CAC9B,CAAC;;AAEF,AAAO,SAAS,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE;IAC5B,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACpB,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC,EAAE;IACvC,CAAC,CAAC,SAAS,GAAG,CAAC,KAAK,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,SAAS,GAAG,CAAC,CAAC,SAAS,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC;CACxF;;AAED,AAAO,IAAI,QAAQ,GAAG,WAAW;IAC7B,QAAQ,GAAG,MAAM,CAAC,MAAM,IAAI,SAAS,QAAQ,CAAC,CAAC,EAAE;QAC7C,KAAK,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;YACjD,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;YACjB,KAAK,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;SAChF;QACD,OAAO,CAAC,CAAC;MACZ;IACD,OAAO,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;EAC1C;;AAED,AAAO,SAAS,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE;IACzB,IAAI,CAAC,GAAG,EAAE,CAAC;IACX,KAAK,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC;QAC/E,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IAChB,IAAI,CAAC,IAAI,IAAI,IAAI,OAAO,MAAM,CAAC,qBAAqB,KAAK,UAAU;QAC/D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,qBAAqB,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACpE,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC1E,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SACzB;IACL,OAAO,CAAC,CAAC;CACZ;;AClDD;;;AAGA,AAAA,IAAY,QAOX;AAPD,WAAY,QAAQ;IAChB,sCAA0B,CAAA;IAC1B,oCAAwB,CAAA;IACxB,6BAAiB,CAAA;IACjB,2BAAe,CAAA;IACf,yBAAa,CAAA;IACb,oCAAwB,CAAA;CAC3B,EAPW,QAAQ,KAAR,QAAQ,QAOnB;;;;;;;;;;;;AAYD,AAAA,IAAY,UAIX;AAJD,WAAY,UAAU;IAClB,2BAAa,CAAA;IACb,6BAAe,CAAA;IACf,2BAAa,CAAA;CAChB,EAJW,UAAU,KAAV,UAAU,QAIrB;AAED,AAAA,IAAY,YAIX;AAJD,WAAY,YAAY;IACpB,6BAAa,CAAA;IACb,6BAAa,CAAA;IACb,+BAAe,CAAA;CAClB,EAJW,YAAY,KAAZ,YAAY,QAIvB;;;ACrBD;;;;;AAKA;IAAA;QACY,MAAC,GAAqB,EAAE,CAAC;KA+EpC;;;;;;;;;IAtEG,2BAAG,GAAH,UACI,QAAuB,EACvB,WAAoC;QAFxC,iBA2BC;QAxBG,eAAyB;aAAzB,UAAyB,EAAzB,qBAAyB,EAAzB,IAAyB;YAAzB,8BAAyB;;QAEzB,KAAK,CAAC,OAAO,CAAC,UAAA,GAAG;YACb,IAAM,IAAI,GACN,KAAI,CAAC,IAAI,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,EAAE,KAAK,GAAG,CAAC,EAAE,GAAA,CAAC;iBACpC,WAAW;sBACN,WAAW,CAAC,IAAI,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,EAAE,KAAK,GAAG,CAAC,EAAE,GAAA,CAAC;sBAC5C,IAAI,CAAC,CAAC;YAChB,IAAI,IAAI,IAAI,QAAQ,EAAE;gBAClB,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAClC,OAAM;aACT;YACD,KAAI,CAAC,CAAC,CAAC,IAAI,CAAC;gBACR,EAAE,EAAE,GAAG,CAAC,EAAE;gBACV,IAAI,EAAE,GAAG,CAAC,IAAI;gBACd,IAAI,EAAE,GAAG,CAAC,IAAI;gBACd,eAAe,EAAE,GAAG,CAAC,eAAe;gBACpC,SAAS,EAAE,GAAG,CAAC,SAAS;gBACxB,OAAO,EAAE,GAAG,CAAC,OAAO;gBACpB,aAAa,EAAE,QAAQ,GAAG,CAAC,QAAQ,CAAC,GAAG,EAAE;gBACzC,aAAa,EAAE,QAAQ,GAAG,CAAC,QAAQ,CAAC,GAAG,EAAE;gBACzC,gBAAgB,EAAE,CAAC;aACtB,CAAC,CAAA;SACL,CAAC,CAAA;KACL;IAED,4BAAI,GAAJ,UAAK,EAAqC;QACtC,OAAO,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;KACzB;;;;;IAKD,4BAAI,GAAJ,UAAK,IAAoB;QACrB,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;KACpB;IAID,sBAAI,iCAAM;;;;aAAV;YACI,OAAO,IAAI,CAAC,CAAC,CAAC,MAAM,CAAA;SACvB;;;OAAA;;;;;IAKD,4BAAI,GAAJ,UAAK,EAAqC;QACtC,OAAO,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;KACzB;;;;;IAKD,6BAAK,GAAL;QACI,OAAO,IAAI,CAAC,CAAC,CAAC,KAAK,EAAE,CAAA;KACxB;;;;;;IAMD,6BAAK,GAAL;QACI,IAAM,QAAQ,GAAG,IAAI,aAAa,EAAK,CAAC;QACxC,QAAQ,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACvC,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC;QACZ,OAAO,QAAQ,CAAA;KAClB;IACL,oBAAC;CAAA,IAAA;;;AC9FD;;;;;;AAMA;IAAA;QACY,MAAC,GAAwC,EAAE,CAAC;KAuLvD;IAlLG,sBAAI,yBAAK;;;;aAAT;YACI,OAAO,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,UAAC,MAAM,EAAE,GAAG,IAAK,QAAC,GAAG,CAAC,MAAM,GAAG,MAAM,GAAG,GAAG,CAAC,MAAM,GAAG,MAAM,IAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC;SAC9F;;;OAAA;IAID,sBAAI,0BAAM;;;;aAAV;YACI,OAAO,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC;SACxB;;;OAAA;;;;;;IAMD,uCAAsB,GAAtB,UAAuB,EAAgB;QAAvC,iBAMC;YANuB,SAAC,EAAE,SAAC;QACxB,IAAM,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACtB,IAAI,CAAC,GAAG;YAAE,OAAO,KAAK,CAAC;QACvB,OAAO,GAAG,CAAC,IAAI,CAAC,UAAC,KAA4B;YACzC,OAAO,CAAC,CAAC,KAAK,IAAI,CAAC,KAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;SACxD,CAAC,CAAC;KACN;;;;;;IAOD,qCAAoB,GAApB,UAAqB,EAAgB;YAAf,SAAC,EAAE,SAAC;QACtB,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,EAAE;YACjB,OAAO,KAAK,CAAC;SAChB;QACD,OAAO,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,UAAC,GAAG,EAAE,KAAK;YAC1B,IAAI,KAAK,GAAG,CAAC,EAAE;gBACX,OAAO,KAAK,CAAC;aAChB;YACD,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;SACnB,CAAC,CAAC;KACN;;;;IAKO,sCAAqB,GAA7B,UAA8B,IAAoB;QAC9C,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,KAAK,IAAI,CAAC,gBAAgB,CAAC;KACrD;;;;;;;;;IAUD,oCAAmB,GAAnB,UAAoB,CAAS;QACzB,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC;YAAE,OAAO,CAAC,CAAC;QAChC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,UAAA,GAAG;YACxB,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;SAClB,CAAC,CAAC;QACH,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;YACV,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;SACnB;QACD,OAAO,CAAC,CAAC;KACZ;;;;;IAKO,8BAAa,GAArB,UAAsB,OAAe;QACjC,OAAO,IAAI,CAAC,MAAM,GAAG,OAAO,EAAE;YAC1B,IAAM,GAAG,GAAiC,EAAE,CAAC;YAC7C,GAAG,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC;YACxB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACf,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;SACpB;KACJ;;;;;IAKO,6BAAY,GAApB,UAAqB,OAAe;QAChC,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,UAAA,GAAG;YACd,OAAO,GAAG,CAAC,MAAM,GAAG,OAAO,EAAE;gBACzB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aAClB;SACJ,CAAC,CAAC;KACN;;;;;IAKD,gCAAe,GAAf,UAAgB,CAAS;QACrB,IAAM,GAAG,GAAiC,EAAE,CAAC;QAC7C,GAAG,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC;QACxB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACf,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;KAC5B;;;;;IAKD,mCAAkB,GAAlB,UAAmB,CAAS;QACxB,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,UAAA,GAAG;YACd,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;SAC1B,CAAC,CAAC;KACN;;;;;;IAMD,qBAAI,GAAJ,UAAK,QAA2C;QAC5C,IAAI,MAAM,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,UAAC,GAAG,EAAE,CAAC;YAClB,GAAG,CAAC,IAAI,CAAC,UAAC,KAAK,EAAE,CAAC;gBACd,IAAI,CAAC,KAAK;oBAAE,OAAO,KAAK,CAAC;gBACzB,IAAI,QAAQ,CAAC,KAAK,CAAC,EAAE;oBACjB,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBAChB,OAAO,IAAI,CAAC;iBACf;gBACD,OAAO,KAAK,CAAC;aAChB,CAAC,CAAC;SACN,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;KACjB;;;;;;IAMD,yBAAQ,GAAR,UAAS,QAA2C;QAChD,IAAI,MAAM,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,UAAC,GAAG,EAAE,CAAC;YAClB,GAAG,CAAC,IAAI,CAAC,UAAC,KAAK,EAAE,CAAC;gBACd,IAAI,CAAC,KAAK;oBAAE,OAAO,KAAK,CAAC;gBACzB,IAAI,QAAQ,CAAC,KAAK,CAAC,EAAE;oBACjB,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;oBACzB,OAAO,IAAI,CAAC;iBACf;gBACD,OAAO,KAAK,CAAC;aAChB,CAAC,CAAC;SACN,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;KACjB;;;;IAID,4BAAW,GAAX,UAAY,CAAS,EAAE,CAAS;QAC5B,OAAO,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KACvB;;;;;;IAMD,uBAAM,GAAN,UAAO,EAAgB,EAAE,IAAoB;YAArC,SAAC,EAAE,SAAC;QACR,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE;YAClB,IAAI,CAAC,aAAa,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;SAC7B;QACD,IAAI,IAAI,CAAC,KAAK,IAAI,CAAC,EAAE;YACjB,IAAI,CAAC,YAAY,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;SAC5B;QAED,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;KACvB;;;;;IAKD,0BAAS,GAAT;QACI,OAAO,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,GAAG,EAAE,CAAC;YAC7B,GAAG,CAAC,OAAO,CAAC,UAAC,IAAI,EAAE,CAAC;gBAChB,IAAI,CAAC,IAAI;oBAAE,OAAO;gBAClB,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,gBAAQ,IAAI,IAAE,CAAC,GAAA,EAAE,CAAC,GAAA,GAAE,CAAC;aACpC,CAAC,CAAC;YACH,OAAO,GAAG,CAAC;SACd,EAAE,EAAE,CAAC,CAAC;KACV;IACL,aAAC;CAAA,IAAA;;;AC9LD,IAAM,UAAU,GAAG,UAAC,GAA+B,EAAE,EAAU,IAAc,OAAA,GAAG,CAAC,EAAE,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC,CAAC,MAAM,GAAG,CAAC,GAAA,CAAC;;;;;;AAO3G;IAMI,qBAAY,IAAqB;QALvB,UAAK,GAAoB,EAAE,CAAC;QAC9B,cAAS,GAAoC,EAAE,CAAC;QAChD,wBAAmB,GAA+B,EAAE,CAAC;QACrD,yBAAoB,GAA+B,EAAE,CAAC;QACtD,sBAAiB,GAA+B,EAAE,CAAC;QAEvD,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;KACxB;;;;;IAKD,+BAAS,GAAT,UAAU,IAAqB;QAC3B,IAAI,CAAC,mBAAmB,GAAG,EAAE,CAAC;QAC9B,IAAI,CAAC,oBAAoB,GAAG,EAAE,CAAC;QAC/B,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QACpB,IAAI,CAAC,iBAAiB,GAAG,EAAE,CAAC;QAC5B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,IAAI;YACnC,IAAI,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;gBAAE,MAAM,IAAI,KAAK,CAAC,kBAAgB,IAAI,CAAC,EAAI,CAAC,CAAC;YAC7D,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;YACpB,OAAO,GAAG,CAAC;SACd,EAAE,EAAE,CAAC,CAAC;QACP,IAAI,CAAC,wBAAwB,EAAE,CAAC;KACnC;IACD,8CAAwB,GAAxB;QAAA,iBAKC;QAJG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,UAAC,QAAQ,EAAE,IAAI;YAC7B,IAAI,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;gBAAE,OAAO,QAAQ,CAAC;YAC3C,OAAO,KAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,IAAI,GAAG,EAAE,EAAE,QAAQ,CAAC,CAAC;SAC7D,EAAE,IAAI,GAAG,EAAU,CAAC,CAAC;KACzB;IACD,wCAAkB,GAAlB,UAAmB,IAAmB,EAAE,SAAsB,EAAE,QAAqB;QAArF,iBAyBC;QAxBG,IAAI,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC;YAAE,MAAM,IAAI,KAAK,CAAC,mCAAiC,IAAI,CAAC,EAAI,CAAC,CAAC;QACxF,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QACvB,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QACtB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,UAAA,SAAS;;YAEvB,IAAI,KAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,EAAE,SAAS,CAAC;gBAAE,OAAO;;YAEhD,IAAI,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;gBAC1B,KAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,KAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE,CAAC;sBAC3D,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAK,KAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE,CAAC,SAAE,SAAS,GAAE,CAAC;sBACpE,CAAC,SAAS,CAAC,CAAC;gBAClB,OAAO;aACV;YACD,KAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,GAAG,KAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC;kBACnE,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAK,KAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,SAAE,IAAI,CAAC,EAAE,GAAE,CAAC;kBACtE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YAChB,KAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,KAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,EAAE,CAAC;kBACjE,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAK,KAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,EAAE,CAAC,SAAE,SAAS,GAAE,CAAC;kBACvE,CAAC,SAAS,CAAC,CAAC;YAClB,QAAQ,GAAG,KAAI,CAAC,kBAAkB,CAAC,KAAI,CAAC,SAAS,CAAC,SAAS,CAAC,EAAE,IAAI,GAAG,CAAC,SAAS,CAAC,EAAE,QAAQ,CAAC,CAAC;YAC5F,OAAO;SACV,CAAC,CAAC;QAEH,OAAO,QAAQ,CAAC;KACnB;;;;;IAKD,2BAAK,GAAL;QAAA,iBAEC;QADG,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,UAAA,IAAI,IAAI,OAAA,KAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,GAAA,CAAC,CAAC;KAC1D;;;;;;IAMS,8BAAQ,GAAlB,UAAmB,EAAU;QACzB,IAAI,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC;QAC/B,QAAQ,IAAI;YACR,KAAK,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC;gBACpC,QAAQ,GAAG,QAAQ,CAAC,SAAS,CAAC;gBAC9B,MAAM;YACV,KAAK,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC;gBAChB,QAAQ,GAAG,QAAQ,CAAC,UAAU,CAAC;gBAC/B,MAAM;YACV,KAAK,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC;gBACpC,QAAQ,GAAG,QAAQ,CAAC,SAAS,CAAC;gBAC9B,MAAM;YACV,KAAK,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC;gBACjB,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC;gBAC1B,MAAM;YACV,KAAK,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC;gBAChB,QAAQ,GAAG,QAAQ,CAAC,IAAI,CAAC;gBACzB,MAAM;SACb;QACD,OAAO,QAAQ,CAAC;KACnB;;;;;IAKO,6BAAO,GAAf,UAAgB,EAAU;QACtB,OAAO,UAAU,CAAC,IAAI,CAAC,oBAAoB,EAAE,EAAE,CAAC,CAAC;KACpD;;;;;IAKO,4BAAM,GAAd,UAAe,EAAU;QACrB,OAAO,UAAU,CAAC,IAAI,CAAC,mBAAmB,EAAE,EAAE,CAAC,CAAC;KACnD;;;;;IAKO,4BAAM,GAAd,UAAe,EAAU;QACrB,OAAO,CAAC,IAAI,CAAC,mBAAmB,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC;KAChF;IACS,gCAAU,GAApB,UAAqB,MAAc,EAAE,SAAiB;QAClD,OAAO,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;KAC/F;;;;;IAKS,2BAAK,GAAf,UAAgB,EAAU;QACtB,OAAO,IAAI,CAAC,iBAAiB,CAAC,EAAE,CAAC,CAAC;KACrC;;;;;IAKS,8BAAQ,GAAlB,UAAmB,EAAU;QACzB,OAAO,IAAI,CAAC,oBAAoB,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC;KAC9C;;;;;IAKS,6BAAO,GAAjB,UAAkB,EAAU;QACxB,OAAO,IAAI,CAAC,mBAAmB,CAAC,EAAE,CAAC,CAAC;KACvC;;;;;IAKS,0BAAI,GAAd,UAAe,EAAU;QACrB,OAAO,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;KAC7B;;;;;IAKS,sCAAgB,GAA1B,UAA2B,MAAc;QAAzC,iBAYC;QAXG,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,UAAA,SAAS;YACtC,IAAM,GAAG,GAAG,KAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YACjC,OAAO;gBACH,EAAE,EAAE,GAAG,CAAC,EAAE;gBACV,IAAI,EAAE,GAAG,CAAC,IAAI;gBACd,IAAI,EAAE,GAAG,CAAC,IAAI;gBACd,eAAe,EAAE,GAAG,CAAC,eAAe;gBACpC,SAAS,EAAE,GAAG,CAAC,SAAS;gBACxB,OAAO,EAAE,GAAG,CAAC,OAAO;aACvB,CAAC;SACL,CAAC,CAAC;KACN;IACL,kBAAC;CAAA,IAAA;;;ACnJD;;;;AAIA;IAAoCA,+BAAc;IAC9C,qBAAY,IAAqB;eAC7B,kBAAM,IAAI,CAAC;KACd;;;;;IAKS,+CAAyB,GAAnC,UAAoC,IAAoB;QACpD,OAAO,IAAI,CAAC,aAAa,CAAC,MAAM,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC;KACpE;;;;;;;;;;;IAWO,+CAAyB,GAAjC,UAAkC,IAAoB,EAAE,KAAe,EAAE,cAAuB;QACpF,IAAA,eAAG,CAAW;;QAEtB,IAAI,cAAc,IAAI,GAAG,CAAC,sBAAsB,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;YAClE,GAAG,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;SAChC;QACD,GAAG,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;QACrC,IAAI,CAAC,oBAAoB,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;KACxC;;;;;;;IAOO,6CAAuB,GAA/B,UAAgC,IAAoB,EAAE,GAAc;QAChE,IAAM,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC;QACnC,IAAI,OAAO,IAAI,OAAO,CAAC,MAAM,EAAE;;YAE3B,IAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,UAAA,EAAE;gBACxB,IAAM,MAAM,GAAG,GAAG,CAAC,IAAI,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,EAAE,KAAK,EAAE,GAAA,CAAC,CAAC;gBAChD,IAAI,CAAC,MAAM;oBAAE,MAAM,IAAI,KAAK,CAAC,kDAA+C,EAAE,OAAG,CAAC,CAAC;gBACnF,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;aACpB,CAAC,CAAC;YACH,OAAO,IAAI,CAAC,GAAG,OAAR,IAAI,EAAQ,KAAK,EAAE;SAC7B;QACD,OAAO,CAAC,CAAC;KACZ;;;;;;;;;;;;;IAcS,gDAA0B,GAApC,UAAqC,IAAoB,EAAE,KAAe;QAC9D,IAAA,eAAG,EAAE,mBAAK,CAAW;QAC7B,IAAI,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE;YACjD,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC,uBAAuB,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;SACrD;QACD,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACrC,IAAM,SAAS,GAAG,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG,IAAI,CAAC;QACvE,IAAM,aAAa,GAAG,QAAQ,IAAI,CAAC,SAAS,CAAC;;QAE7C,IAAI,GAAG,CAAC,oBAAoB,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,aAAa,EAAE;YAC/D,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACjB,OAAO,KAAK,CAAC;SAChB;QACD,IAAI,CAAC,yBAAyB,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;QACnD,IAAI,SAAS,EAAE;YACX,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC;SACjD;QACD,OAAO,IAAI,CAAC;KACf;IAEO,8BAAQ,GAAhB,UAAiB,IAAoB;QACjC,OAAO,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KAChC;IAEO,sCAAgB,GAAxB,UAAyB,IAAoB,EAAE,KAAe;QAClD,IAAA,eAAG,CAAW;QACtB,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAClC,IAAI,CAAC,KAAK;YAAE,MAAM,IAAI,KAAK,CAAC,6BAA2B,IAAI,CAAC,EAAI,CAAC,CAAC;QAClE,IAAM,SAAS,GAAG,KAAK,CAAC,GAAG,CAAC,UAAA,QAAQ;YAChC,IAAI,IAAI,CAAC,EAAE,KAAK,QAAQ,EAAE;gBACtB,OAAO;oBACH,EAAE,EAAE,QAAQ;oBACZ,IAAI,EAAE,IAAI;oBACV,MAAM,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;oBAC1B,UAAU,EAAE,IAAI;iBACnB,CAAC;aACL;YACD,IAAM,MAAM,GAAG,GAAG,CAAC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,EAAE,KAAK,QAAQ,GAAA,CAAC,CAAC;YAChD,IAAI,CAAC,MAAM;gBAAE,MAAM,IAAI,KAAK,CAAC,kBAAgB,QAAQ,0BAAuB,CAAC,CAAC;YAC9E,IAAM,IAAI,GAAG,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;YACnD,IAAI,CAAC,IAAI;gBAAE,MAAM,IAAI,KAAK,CAAC,sBAAoB,QAAQ,0BAAuB,CAAC,CAAC;YAChF,OAAO;gBACH,EAAE,EAAE,QAAQ;gBACZ,IAAI,MAAA;gBACJ,MAAM,QAAA;aACT,CAAC;SACL,CAAC,CAAC;QACH,IAAM,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC,UAAA,MAAM;YACtB,IAAA,sBAAM,CAAY;YAC1B,OAAO,GAAG,CAAC,oBAAoB,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;SAC7E,CAAC,CAAC;QACH,IAAI,IAAI;YAAE,OAAO,IAAI,CAAC;QACtB,OAAO,SAAS,CAAC;KACpB;IAEO,0CAAoB,GAA5B,UAA6B,GAAc,EAAE,IAAoB;QAC7D,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,UAAA,QAAQ;YAC/B,IAAM,KAAK,GAAG,GAAG,CAAC,QAAQ,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,EAAE,KAAK,QAAQ,GAAA,CAAC,CAAC;YACnD,IAAI,CAAC,KAAK;gBAAE,MAAM,IAAI,KAAK,CAAC,YAAU,QAAQ,0BAAuB,CAAC,CAAC;YAChE,IAAA,iBAAM,EAAE,iBAAM,CAAU;YAC/B,MAAM,CAAC,gBAAgB,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,gBAAgB,GAAG,CAAC,EAAE,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACpF,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;SAC9B,CAAC,CAAC;KACN;IAES,gDAA0B,GAApC,UAAqC,GAAc,EAAE,IAAoB;QACrE,IAAI,CAAC,oBAAoB,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QACrC,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;KAC3B;IAEO,sCAAgB,GAAxB,UAAyB,IAAoB,EAAE,KAAe,EAAE,SAAwB;QAAxF,iBA2EC;QA1EW,IAAA,eAAG,CAAW;QACtB,IAAM,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC;QACzB,IAAI,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC;QACvB,SAAS,CAAC,OAAO,CAAC,UAAA,MAAM;YACZ,IAAA,cAAE,EAAE,sBAAM,EAAE,kBAAI,CAAY;YACpC,IAAI,cAAc,GAAG,IAAI,CAAC,EAAE,CAAC;YAC7B,IAAI,MAAM,CAAC,UAAU,EAAE;gBACnB,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC;gBACnB,KAAK,CAAC,CAAC,GAAG,QAAQ,GAAG,CAAC,CAAC;gBACvB,IAAM,UAAU,GAAM,EAAE,UAAO,CAAC;gBAChC,cAAc,GAAG,UAAU,CAAC;gBAC5B,KAAI,CAAC,yBAAyB,CAC1B;oBACI,EAAE,EAAE,UAAU;oBACd,UAAU,EAAE,UAAU,CAAC,IAAI;oBAC3B,YAAY,EAAE,YAAY,CAAC,IAAI;oBAC/B,UAAU,EAAE,IAAI,CAAC,EAAE;oBACnB,QAAQ,EAAE,EAAE;oBACZ,QAAQ,EAAE,IAAI;oBACd,aAAa,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;oBACxB,aAAa,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;oBACxB,OAAO,EAAE,IAAI,CAAC,OAAO;oBACrB,IAAI,EAAE,CAAC,EAAE,CAAC;oBACV,gBAAgB,EAAE,CAAC;iBACtB,EACD,KAAK,EACL,KAAK,CACR,CAAC;aACL;YACD,KAAK,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YACpB,IAAM,aAAa,GAAG,GAAG,CAAC,MAAM,CAAC;YACjC,IAAM,MAAM,GAAM,EAAE,SAAI,IAAI,CAAC,EAAE,UAAO,CAAC;YACvC,IAAM,IAAI,GAAM,EAAE,SAAI,IAAI,CAAC,EAAE,QAAK,CAAC;YACnC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,GAAO,IAAI,CAAC,aAAa,SAAE,MAAM,KAAI,CAAC,MAAM,CAAC,CAAC;YACrF,KAAI,CAAC,yBAAyB,CAC1B;gBACI,EAAE,EAAE,IAAI;gBACR,UAAU,EAAE,UAAU,CAAC,IAAI;gBAC3B,YAAY,EAAE,YAAY,CAAC,IAAI;gBAC/B,UAAU,EAAE,IAAI,CAAC,EAAE;gBACnB,QAAQ,EAAE,EAAE;gBACZ,QAAQ,EAAE,IAAI;gBACd,aAAa,EAAE,CAAC,cAAc,CAAC;gBAC/B,aAAa,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;gBACxB,OAAO,EAAE,IAAI,CAAC,OAAO;gBACrB,IAAI,EAAE,CAAC,EAAE,CAAC;gBACV,gBAAgB,EAAE,CAAC;aACtB,EACD,KAAK,EACL,IAAI,CACP,CAAC;YACF,IAAI,aAAa,KAAK,GAAG,CAAC,MAAM;gBAAE,QAAQ,EAAE,CAAC;YAC7C,KAAK,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YACpB,KAAI,CAAC,yBAAyB,CAC1B;gBACI,EAAE,EAAE,MAAM;gBACV,UAAU,EAAE,UAAU,CAAC,IAAI;gBAC3B,YAAY,EAAE,YAAY,CAAC,KAAK;gBAChC,UAAU,EAAE,IAAI,CAAC,EAAE;gBACnB,QAAQ,EAAE,EAAE;gBACZ,QAAQ,EAAE,IAAI;gBACd,aAAa,EAAE,CAAC,IAAI,CAAC;gBACrB,aAAa,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;gBACxB,OAAO,EAAE,IAAI,CAAC,OAAO;gBACrB,IAAI,EAAE,CAAC,EAAE,CAAC;gBACV,gBAAgB,EAAE,CAAC;aACtB,EACD,KAAK,EACL,KAAK,CACR,CAAC;YACF,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC;SACtB,CAAC,CAAC;QACH,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC;QACnB,OAAO,KAAK,CAAC;KAChB;;;;;;;IAOS,0CAAoB,GAA9B,UAA+B,IAAoB,EAAE,KAAe,EAAE,UAA4B;QAAlG,iBAuCC;QAtCW,IAAA,mBAAK,CAAW;QACxB,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;;QAExC,IAAM,cAAc,GAAG,QAAQ,CAAC,KAAK,EAAE,CAAC;QACxC,IAAI,CAAC,cAAc;YAAE,MAAM,IAAI,KAAK,CAAC,aAAU,IAAI,CAAC,EAAE,uBAAmB,CAAC,CAAC;QAC3E,IAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QACxC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE,UAAU,EAAE;YAC3B,EAAE,EAAE,KAAK,CAAC,EAAE;YACZ,IAAI,EAAE,KAAK,CAAC,IAAI;YAChB,IAAI,EAAE,KAAK,CAAC,IAAI;YAChB,eAAe,EAAE,KAAK,CAAC,eAAe;YACtC,SAAS,EAAE,KAAK,CAAC,SAAS;YAC1B,OAAO,EAAE,KAAK,CAAC,OAAO;SACzB,CAAC,CAAC;;QAEH,QAAQ,CAAC,OAAO,CAAC,UAAA,SAAS;YACtB,KAAK,CAAC,CAAC,EAAE,CAAC;YACV,IAAM,EAAE,GAAM,IAAI,CAAC,EAAE,SAAI,SAAW,CAAC;YAErC,KAAI,CAAC,yBAAyB,CAC1B;gBACI,EAAE,EAAE,EAAE;gBACN,UAAU,EAAE,UAAU,CAAC,KAAK;gBAC5B,YAAY,EAAE,YAAY,CAAC,KAAK;gBAChC,UAAU,EAAE,IAAI,CAAC,EAAE;gBACnB,QAAQ,EAAE,SAAS;gBACnB,QAAQ,EAAE,IAAI;gBACd,aAAa,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;gBACxB,aAAa,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;gBACxB,OAAO,EAAE,IAAI,CAAC,OAAO;gBACrB,IAAI,EAAE,CAAC,SAAS,CAAC;gBACjB,gBAAgB,EAAE,CAAC;aACtB,EACD,KAAK,EACL,IAAI,CACP,CAAC;YACF,KAAK,CAAC,GAAG,CAAC,EAAE,EAAE,UAAU,eAAO,KAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAAG,CAAC;SAC1D,CAAC,CAAC;KACN;;;;;;;;IAQS,wCAAkB,GAA5B,UACI,IAAoB,EACpB,KAAe,EACf,UAA4B,EAC5B,cAAuB;QAJ3B,iBAyCC;QAnCW,IAAA,eAAG,EAAE,mBAAK,CAAW;QAC7B,IAAM,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC;QAEnC,IAAM,OAAO,GAAG,IAAI,CAAC,uBAAuB,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;QACxD,OAAO,CAAC,OAAO,CAAC,UAAA,QAAQ;YACpB,IAAM,KAAK,GAAG,GAAG,CAAC,QAAQ,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,EAAE,KAAK,QAAQ,GAAA,CAAC,CAAC;YACnD,IAAI,CAAC,KAAK;gBAAE,MAAM,IAAI,KAAK,CAAC,YAAU,QAAQ,0BAAuB,CAAC,CAAC;YAChE,IAAA,aAAK,EAAF,SAAC,EAAG,iBAAM,CAAU;YAC9B,IAAI,OAAO,KAAK,CAAC,EAAE;gBACf,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAClC,MAAM,CAAC,gBAAgB,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,gBAAgB,GAAG,CAAC,EAAE,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBACpF,OAAO;aACV;YACD,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC;YACZ,IAAM,EAAE,GAAM,QAAQ,SAAI,IAAI,CAAC,EAAI,CAAC;YACpC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YAC5B,KAAI,CAAC,yBAAyB,CAC1B;gBACI,EAAE,EAAE,EAAE;gBACN,UAAU,EAAE,UAAU,CAAC,IAAI;gBAC3B,YAAY,EAAE,YAAY,CAAC,IAAI;gBAC/B,UAAU,EAAE,QAAQ;gBACpB,QAAQ,EAAE,IAAI,CAAC,EAAE;gBACjB,QAAQ,EAAE,IAAI;gBACd,aAAa,EAAE,CAAC,QAAQ,CAAC;gBACzB,aAAa,EAAE,CAAC,QAAQ,CAAC;gBACzB,OAAO,EAAE,IAAI,CAAC,OAAO;gBACrB,IAAI,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;gBACf,gBAAgB,EAAE,CAAC;aACtB,EACD,KAAK,EACL,KAAK,CACR,CAAC;SACL,CAAC,CAAC;QACH,IAAI,cAAc;YAAE,KAAK,CAAC,GAAG,OAAT,KAAK,GAAK,IAAI,CAAC,EAAE,EAAE,UAAU,SAAK,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC,GAAE;KACzF;IACL,kBAAC;CA/SD,CAAoC,WAAW,GA+S9C;;;ACpUD,IAAM,cAAc,GAAG,KAAK,CAAC;;;;;;AAiB7B;IAA8BA,yBAAc;IACxC,eAAY,IAAqB;eAC7B,kBAAM,IAAI,CAAC;KACd;;;;;;;IAOO,gCAAgB,GAAxB,UACI,IAAoB,EACpB,KAAe,EACf,UAA4B;QAE5B,IAAI,UAAU,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAC9D,IAAI,UAAU,EAAE;YACZ,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;SACtD;KACJ;;;;;;;IAOO,oCAAoB,GAA5B,UACI,IAAoB,EACpB,KAAe,EACf,UAA4B;QAEpB,IAAA,mBAAK,EAAE,eAAG,CAAW;QAC7B,IAAI,UAAU,GAAG,KAAK,CAAC;QACvB,IAAI,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,EAAE;YACtC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACpB;aAAM;YACH,IAAI,CAAC,0BAA0B,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;YAC3C,UAAU,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YAC1D,IAAI,UAAU,EAAE;gBACZ,IAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;gBACxD,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;aACtD;SACJ;QACD,OAAO,UAAU,CAAC;KACrB;;;;;;;IAOO,+BAAe,GAAvB,UACI,IAAoB,EACpB,KAAe,EACf,UAA4B;QAEpB,IAAA,mBAAK,EAAE,eAAG,CAAW;QAC7B,IAAI,UAAU,GAAG,KAAK,CAAC;QACvB,IAAI,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,EAAE;YACtC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACpB;aAAM;YACH,IAAI,CAAC,0BAA0B,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;YAC3C,UAAU,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YAC1D,IAAI,UAAU,EAAE;gBACZ,IAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;aAC1D;SACJ;QACD,OAAO,UAAU,CAAC;KACrB;;;;;;;IAOO,iCAAiB,GAAzB,UACI,IAAoB,EACpB,KAAe,EACf,UAA4B;QAEpB,IAAA,mBAAK,CAAW;QACxB,IAAI,UAAU,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAC9D,IAAI,UAAU,EAAE;YACZ,KAAK,CAAC,GAAG,OAAT,KAAK,GAAK,IAAI,CAAC,EAAE,EAAE,UAAU,SAAK,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC,GAAE;SACrE;QACD,OAAO,UAAU,CAAC;KACrB;;;;;;;IAOO,6BAAa,GAArB,UACI,IAAoB,EACpB,KAAe,EACf,UAA4B;QAEpB,IAAA,eAAG,CAAW;QACtB,QAAQ,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;YAC1B,KAAK,QAAQ,CAAC,UAAU;;gBAEpB,KAAK,CAAC,CAAC,GAAG,GAAG,CAAC,mBAAmB,CAAC,CAAC,CAAC,CAAC;YACzC,KAAK,QAAQ,CAAC,MAAM;gBAChB,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;gBAChD,MAAM;YACV,KAAK,QAAQ,CAAC,SAAS;;gBAEnB,KAAK,CAAC,CAAC,GAAG,GAAG,CAAC,mBAAmB,CAAC,CAAC,CAAC,CAAC;YACzC,KAAK,QAAQ,CAAC,KAAK;gBACf,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;gBAC/C,MAAM;YACV,KAAK,QAAQ,CAAC,IAAI;gBACd,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;gBAC9C,MAAM;YACV,KAAK,QAAQ,CAAC,SAAS;gBACnB,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;gBACnD,MAAM;SACb;KACJ;;;;;IAKO,8BAAc,GAAtB,UAAuB,UAAkB,EAAE,KAAe;QAC9C,IAAA,mBAAK,CAAW;QACxB,IAAM,UAAU,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC;QACjC,OAAO,UAAU,CAAC,MAAM,EAAE;YACtB,UAAU,EAAE,CAAC;YACb,IAAM,IAAI,GAAG,UAAU,CAAC,KAAK,EAAE,CAAC;YAChC,IAAI,CAAC,IAAI;gBAAE,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;YAC7D,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;YAC5C,IAAI,UAAU,GAAG,cAAc,EAAE;gBAC7B,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;aACpC;SACJ;QACD,OAAO,UAAU,CAAC;KACrB;;;;;IAKO,6BAAa,GAArB,UAAsB,KAAe;QACjC,IAAI,KAAK,GAAG,CAAC,CAAC;QACN,IAAA,eAAG,EAAE,mBAAK,CAAW;QAC7B,OAAO,KAAK,CAAC,MAAM,EAAE;YACjB,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;YAC1C,KAAK,CAAC,CAAC,EAAE,CAAC;SACb;QACD,OAAO,GAAG,CAAC;KACd;;;;;IAKD,wBAAQ,GAAR;QACI,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC;QAC3B,IAAM,KAAK,GAAa;YACpB,GAAG,EAAE,IAAI,MAAM,EAAK;YACpB,KAAK,EAAE,IAAI,aAAa,EAAE;YAC1B,CAAC,EAAE,CAAC;YACJ,CAAC,EAAE,CAAC;SACP,CAAC;QACF,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;YACf,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM;gBAAE,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;YAC5D,OAAO,KAAK,CAAC,GAAG,CAAC;SACpB;QACO,IAAA,eAAG,EAAE,mBAAK,CAAW;QAC7B,KAAK,CAAC,GAAG,OAAT,KAAK,GACD,IAAI;YACJ,IAAI,SACD,KAAK,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,QAAC;YACf,EAAE,EAAE,CAAC,CAAC,EAAE;YACR,IAAI,EAAE,CAAC,CAAC,IAAI;YACZ,IAAI,EAAE,CAAC,CAAC,IAAI;YACZ,eAAe,EAAE,CAAC,CAAC,eAAe;YAClC,SAAS,EAAE,CAAC,CAAC,SAAS;YACtB,OAAO,EAAE,CAAC,CAAC,OAAO;SACrB,IAAC,CAAC,GACL;QACF,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;QAC1B,OAAO,GAAG,CAAC;KACd;IACL,YAAC;CAvLD,CAA8B,WAAW,GAuLxC;;;;;AC7MD,SAAS,WAAW,CAAC,GAAG,EAAE,GAAG,EAAE;EAC7B,KAAK,GAAG,KAAK,KAAK,CAAC,GAAG,GAAG,GAAG,EAAE,CAAC;EAC/B,IAAI,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC;;EAE5B,IAAI,CAAC,GAAG,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE,EAAE,OAAO,EAAE;;EAExD,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI,IAAI,QAAQ,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;EACrE,IAAI,KAAK,GAAG,QAAQ,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;EAC5C,KAAK,CAAC,IAAI,GAAG,UAAU,CAAC;;EAExB,IAAI,QAAQ,KAAK,KAAK,EAAE;IACtB,IAAI,IAAI,CAAC,UAAU,EAAE;MACnB,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;KAC3C,MAAM;MACL,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;KACzB;GACF,MAAM;IACL,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;GACzB;;EAED,IAAI,KAAK,CAAC,UAAU,EAAE;IACpB,KAAK,CAAC,UAAU,CAAC,OAAO,GAAG,GAAG,CAAC;GAChC,MAAM;IACL,KAAK,CAAC,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC;GACjD;CACF;;;;;;ACpBD;IAAwCA,mCAEvC;IAFD;;KA+CC;IA5CG,kCAAQ,GAAR,UAAS,IAAmB,EAAE,OAAwB;QAClD,IAAI,OAAO,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC;YAClE,OAAO,MAAM,CAAC,UAAU,CAAC;QAC7B,IAAI,OAAO,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC;YAAE,OAAO,MAAM,CAAC,UAAU,CAAC;QAC5D,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC;YAAE,OAAO,MAAM,CAAC,SAAS,CAAC;QAC/D,OAAO,MAAM,CAAC,QAAQ,CAAC;KAC1B;IACD,oCAAU,GAAV,UAAW,EAAU;QACjB,QACIC;YACIA,8BACI,WAAW,EAAC,GAAG,EACf,CAAC,EAAC,GAAG,EACL,CAAC,EAAC,GAAG,EACL,EAAE,EAAC,IAAI,EACP,EAAE,EAAC,IAAI,EACP,UAAU,EAAC,QAAQ,IAElB,EAAE,CACA,CACP,EACN;KACL;IACD,gCAAM,GAAN;QACU,IAAA,eAA8B,EAA5B,cAAI,EAAE,oBAAO,CAAgB;QACrC,QACIA,6BACI,OAAO,EAAC,KAAK,EACb,CAAC,EAAC,KAAK,EACP,CAAC,EAAC,KAAK,EACP,OAAO,EAAC,WAAW,EACnB,SAAS,EAAE,MAAM,CAAC,eAAe;YAEjCA,2BACI,SAAS,EAAE,uBACP,MAAM,CAAC,oBAAoB,SAC3B,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,OAAO,CAAG;gBAElCA,8BAAM,CAAC,EAAC,0JAA0J,GAAG;gBACpK,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC,CACzB,CACF,EACR;KACL;IACL,sBAAC;CAAA,CA/CuCC,eAAe,GA+CtD;;;AC3CM,IAAM,iBAAiB,GAAG,UAC7B,mBAA2C,IACJ,OAAA,UAAC,EAMnB;IALrB,IAAA,gBAAK,EACL,kBAAM,EACN,QAAC,EACD,QAAC,EACD,iDAAQ;IACkB,QAC1BD,uCACI,CAAC,EAAE,CAAC,EACJ,CAAC,EAAE,CAAC,EACJ,KAAK,EAAE,KAAK,EACZ,MAAM,EAAE,MAAM,EACd,SAAS,EAAE,WAAW;QAEtBA,oBAAC,mBAAmB,eAAK,KAAU,EAAI,CAC3B,EACnB;CAAA,GAAA,CAAC;;;ACXF;IAAqCD,gCAEpC;IAFD;QAAA,qEAiJC;QAlIG,sBAAgB,GAAG,UACf,EAAqB,EACrB,IAAoB,EACpB,OAAyB;YAEzB,OAAO,UAAC,CAAmB,IAAK,OAAA,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,OAAO,CAAC,GAAA,CAAC;SACxD,CAAC;QAEF,sBAAgB,GAAG,UACf,IAAoB,EACpB,QAA0C;YAE1C,IAAI,CAAC,IAAI,CAAC,QAAQ;gBAAE,OAAO,IAAI,CAAC;YAChC,KAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC;YACpC,OAAO,KAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;SAC3E,CAAC;QAWF,oBAAc,GAAG,UACb,IAAoB,EACpB,QAA0C;YAE1C,OAAO,KAAI,CAAC,aAAa,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,GAAG,CAAC,UAAA,CAAC;gBAC3C,OAAA,KAAI,CAAC,gBAAgB,CAAC,CAAC,EAAE,QAAQ,CAAC;aAAA,CACrC,CAAC;SACL,CAAC;QAEF,mBAAa,GAAG,UACZ,IAAoB,EACpB,QAA0C,IACvB,OAAA,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAA,EAAE,IAAI,OAAA,QAAQ,CAAC,EAAE,CAAC,GAAA,CAAC,GAAA,CAAC;;KA4FrE;IA9IG,gCAAS,GAAT,UACI,QAAgB,EAChB,OAAe,EACf,IAAoB;QAEpB,OAAO,CAAC,IAAI,CAAC,CAAC,GAAG,QAAQ,GAAG,OAAO,EAAE,IAAI,CAAC,CAAC,GAAG,QAAQ,GAAG,OAAO,CAAC,CAAC;KACrE;IAED,8BAAO,GAAP,UAAQ,QAAgB,EAAE,OAAe;QACrC,OAAO,QAAQ,GAAG,OAAO,GAAG,CAAC,CAAC;KACjC;IAmBD,+CAAwB,GAAxB,UAAyB,IAAoB;QACzC,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,IAAI,CAAC;YAC9B,MAAM,IAAI,KAAK,CACX,8BACI,IAAI,CAAC,EAAE,kBACE,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,CAAG,CAC9C,CAAC;KACT;IAgBD,sCAAe,GAAf;QACU,IAAA,eAMQ,EALV,cAAI,EACJ,sBAAQ,EACR,4BAAW,EACX,sCAAgB,EAChB,sCAAgB,CACL;QACf,IAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QACpD,IAAM,QAAQ,GAEV,EAAE,CAAC;QACP,IAAI,WAAW;YACX,QAAQ,CAAC,OAAO,GAAG,IAAI,CAAC,gBAAgB,CACpC,WAAW,EACX,IAAI,EACJ,OAAO,CACV,CAAC;QACN,IAAI,gBAAgB;YAChB,QAAQ,CAAC,YAAY,GAAG,IAAI,CAAC,gBAAgB,CACzC,gBAAgB,EAChB,IAAI,EACJ,OAAO,CACV,CAAC;QACN,IAAI,gBAAgB;YAChB,QAAQ,CAAC,YAAY,GAAG,IAAI,CAAC,gBAAgB,CACzC,gBAAgB,EAChB,IAAI,EACJ,OAAO,CACV,CAAC;QACN,OAAO,QAAQ,CAAC;KACnB;IAED,iCAAU,GAAV;QACU,IAAA,eAAwG,EAAtG,cAAI,EAAE,YAAoD,EAA5C,sBAAQ,EAAE,cAAI,EAAE,uBAA0B,EAA1B,+CAA0B,EAAI,sBAAQ,EAAE,sBAAQ,EAAE,oBAAO,CAAgB;QACzG,IAAA,4CAAgD,EAA/C,SAAC,EAAE,SAAC,CAA4C;QACvD,IAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAC7C,IAAM,QAAQ,GAAG,iBAAiB,CAC9B,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,eAAe,CAChE,CAAC;QACF,IAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QACpD,IAAM,KAAK,GAAG,eAAe,KAAK,KAAK;cACjC,CAAC,GAAG,IAAI,GAAG,GAAG;cACd,CAAC,GAAG,IAAI,GAAG,GAAG,CAAC;QACrB,QACI,CAAC,QAAQ,KACLC,oCAAG,SAAS,EAAC,iBAAiB,IAAK,IAAI,CAAC,eAAe,EAAE;YACrDA,oBAAC,QAAQ,IACL,CAAC,EAAE,CAAC,EACJ,CAAC,EAAE,CAAC,EACJ,MAAM,EAAE,IAAI,EACZ,KAAK,EAAE,IAAI,EACX,IAAI,EAAE,IAAI,EACV,OAAO,EAAE,OAAO,GAClB;YACD,CAAC,CAAC,IAAI,KACHA,8BACI,CAAC,EAAE,CAAC,GAAG,IAAI,GAAG,GAAG,EACjB,CAAC,EAAE,KAAK,EACR,UAAU,EAAC,QAAQ,EACnB,gBAAgB,EAAC,QAAQ,EACzB,KAAK,EAAE;oBACH,MAAM,EAAE,MAAM;oBACd,WAAW,EAAE,CAAC;oBACd,IAAI,EAAE,SAAS;oBACf,UAAU,EAAE,QAAQ;iBACvB,IAEA,IAAI,CACF,CACV,CACD,CACP,EACH;KACL;IAED,6BAAM,GAAN;QACI,QACIA,2BACI,SAAS,EAAC,YAAY,EACtB,KAAK,EAAE;gBACH,WAAW,EAAE,CAAC;gBACd,IAAI,EAAE,SAAS;gBACf,MAAM,EAAE,SAAS;aACpB,IAEA,IAAI,CAAC,UAAU,EAAE,CAClB,EACN;KACL;IACL,mBAAC;CAAA,CAjJoCC,eAAe,GAiJnD;;;AC/JD,IAAY,eAKX;AALD,WAAY,eAAe;IACvB,8BAAW,CAAA;IACX,oCAAiB,CAAA;IACjB,kCAAe,CAAA;IACf,gCAAa,CAAA;CAChB,EALW,eAAe,KAAf,eAAe,QAK1B;AAED,IAAM,mBAAmB,GAAG,UAAC,EAAU,EAAE,EAAU;IAC/C,OAAO,EAAE,GAAG,EAAE,GAAG,eAAe,CAAC,KAAK,GAAG,eAAe,CAAC,IAAI,CAAC;CACjE,CAAC;AAEF,IAAM,mBAAmB,GAAG,UAAC,EAAU,EAAE,EAAU;IAC/C,OAAO,EAAE,GAAG,EAAE,GAAG,eAAe,CAAC,MAAM,GAAG,eAAe,CAAC,GAAG,CAAC;CACjE,CAAC;AAEF,AAAO,IAAM,cAAc,GAAG,UAC1B,IAAoB,EACpB,MAAsB;IAEtB,IAAI,MAAM,GAAG,CAAC,YAAY,CAAC,IAAI,EAAE,YAAY,CAAC,IAAI,CAAC,CAAC;IACpD,QAAQ,IAAI;QACR,KAAK,IAAI,CAAC,QAAQ,IAAI,MAAM,CAAC,QAAQ;YACjC,MAAM,GAAG;gBACL,IAAI,CAAC,YAA4B;gBACjC,MAAM,CAAC,YAA4B;aACtC,CAAC;YACF,MAAM;QACV,KAAK,IAAI,CAAC,QAAQ;YACd,MAAM,GAAG;gBACL,IAAI,CAAC,YAA4B;gBACjC,IAAI,CAAC,YAA4B;aACpC,CAAC;YACF,MAAM;QACV,KAAK,MAAM,CAAC,QAAQ;YAChB,MAAM,GAAG;gBACL,MAAM,CAAC,YAA4B;gBACnC,MAAM,CAAC,YAA4B;aACtC,CAAC;YACF,MAAM;KACb;IACD,OAAO,MAAM,CAAC;CACjB,CAAC;AAEF,AAAO,IAAM,kBAAkB,GAAG,UAC9B,EAAU,EACV,EAAU,EACV,EAAU,EACV,EAAU;IAEV,OAAO,EAAE,KAAK,EAAE;UACV,mBAAmB,CAAC,EAAE,EAAE,EAAE,CAAC;UAC3B,mBAAmB,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;CACrC,CAAC;AAEF,IAAM,SAAS,GAAG,UACd,MAAoB,EACpB,OAAe,EACf,QAAgB;IAEhB,IAAI,MAAM,KAAK,YAAY,CAAC,IAAI;QAAE,OAAO,CAAC,CAAC;IAC3C,IAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,QAAQ,GAAG,OAAO,GAAG,CAAC,IAAI,IAAI,CAAC,CAAC;IACzD,OAAO,MAAM,KAAK,YAAY,CAAC,IAAI,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC;CACtD,CAAC;AAEF,AAAO,IAAM,aAAa,GAAG,UACzB,QAAgB,EAChB,OAAe,EACf,KAAa,EACb,KAAa,EACb,MAAoB;IAEpB,IAAM,MAAM,GAAG,SAAS,CAAC,MAAM,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;IACpD,IAAM,CAAC,GAAG,KAAK,GAAG,QAAQ,GAAG,QAAQ,GAAG,GAAG,GAAG,MAAM,CAAC;IACrD,IAAM,CAAC,GAAG,KAAK,GAAG,QAAQ,GAAG,QAAQ,GAAG,GAAG,CAAC;IAC5C,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;CACjB,CAAC;AAEF,AAAO,IAAM,YAAY,GAAG,UACxB,SAA0B,EAC1B,QAAgB,EAChB,OAAe,EACf,KAAa,EACb,KAAa,EACb,MAAoB;IAEpB,QAAQ,SAAS;QACb,KAAK,eAAe,CAAC,GAAG;YACf,IAAA,6DAAC,CAA2D;YACjE,IAAI,CAAC,GAAG,KAAK,GAAG,QAAQ,GAAG,OAAO,CAAC;YACnC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAClB,KAAK,eAAe,CAAC,MAAM;YAClB,IAAA,6DAAC,CAA2D;YACjE,IAAI,CAAC,GAAG,KAAK,GAAG,QAAQ,IAAI,QAAQ,GAAG,OAAO,CAAC,CAAC;YAChD,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAClB,KAAK,eAAe,CAAC,KAAK;YAClB,IAAA,2DAA8D,EAA3D,SAAC,CAA2D;YACnE,IAAI,CAAC,GAAG,KAAK,GAAG,QAAQ,IAAI,QAAQ,GAAG,OAAO,CAAC,CAAC;YAChD,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAClB,KAAK,eAAe,CAAC,IAAI;YACjB,IAAA,2DAA8D,EAA3D,SAAC,CAA2D;YACnE,IAAI,CAAC,GAAG,KAAK,GAAG,QAAQ,GAAG,OAAO,CAAC;YACnC,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;KACrB;CACJ,CAAC;AAEF;IACI,OAAO,IAAI,CAAC,MAAM,EAAE;SACf,QAAQ,CAAC,EAAE,CAAC;SACZ,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;CAClB;AAED,kBAAyB,MAAc;IACnC,OAAO,CAAC,MAAM,IAAI,EAAE,EAAE,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;CAC5E;;;AC3GD;IAAuCF,qCAAmB;IAA1D;;KAaC;IAZG,kCAAM,GAAN;QACI,QACIC;YACIA,gCAAQ,EAAE,EAAC,YAAY;gBACnBA,kCACI,MAAM,EAAC,MAAM,EACb,MAAM,EAAE,0BAA0B,GACpC,CACG,CACN,EACT;KACL;IACL,wBAAC;CAAA,CAbsCE,mBAAmB,GAazD;AAED;IAAmCH,iCAA0B;IAA7D;;KAkBC;IAjBG,8BAAM,GAAN;QACU,IAAA,eAAkC,EAAhC,UAAE,EAAE,gBAAK,EAAE,kBAAM,CAAgB;QACzC,QACIC,gCACI,EAAE,EAAE,EAAE,EACN,OAAO,EAAE,WAAW,EACpB,IAAI,EAAE,EAAE,EACR,IAAI,EAAE,EAAE,EACR,WAAW,EAAC,gBAAgB,EAC5B,MAAM,EAAC,MAAM,EACb,WAAW,EAAE,KAAK,EAClB,YAAY,EAAE,MAAM;YAEpBA,6BAAK,SAAS,EAAC,aAAa,GAAG,CAC1B,EACX;KACL;IACL,oBAAC;CAAA,CAlBkCE,mBAAmB,GAkBrD;;;;ACzCD,AA4BA,8BACI,SAA0B,EAC1B,QAAgB,EAChB,OAAe,EACf,IAAoB,EACpB,MAAoB;;IAEpB,IAAI,EAAE,EAAE,EAAE,CAAC;IACX,IAAI,IAAI,CAAC,QAAQ,EAAE;QACf,6DAAmE,EAAlE,UAAE,EAAE,UAAE,CAA6D;KACvE;SAAM;QACH,uEAOC,EAPA,UAAE,EAAE,UAAE,CAOL;KACL;IACD,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;CACnB;AAED,IAAM,iBAAiB;IACnB,GAAC,eAAe,CAAC,GAAG,IAAG,CAAC,eAAe,CAAC,GAAG,EAAE,eAAe,CAAC,MAAM,CAAC;IACpE,GAAC,eAAe,CAAC,MAAM,IAAG,CAAC,eAAe,CAAC,MAAM,EAAE,eAAe,CAAC,GAAG,CAAC;IACvE,GAAC,eAAe,CAAC,KAAK,IAAG,CAAC,eAAe,CAAC,KAAK,EAAE,eAAe,CAAC,IAAI,CAAC;IACtE,GAAC,eAAe,CAAC,IAAI,IAAG,CAAC,eAAe,CAAC,IAAI,EAAE,eAAe,CAAC,KAAK,CAAC;OACxE,CAAC;AAEF;IAAsCH,iCAErC;IAFD;QAAA,qEAmVC;QAxPG,sBAAgB,GAAG,UACf,EAAqB,EACrB,IAAoB,EACpB,OAAyB;YAEzB,OAAO,UAAC,CAAmB,IAAK,OAAA,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,OAAO,CAAC,GAAA,CAAC;SACxD,CAAC;QAEF,sBAAgB,GAAG,UACf,IAAoB,EACpB,QAA0C;YAE1C,IAAI,CAAC,IAAI,CAAC,QAAQ;gBAAE,OAAO,IAAI,CAAC;YAChC,KAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC;YACpC,OAAO,KAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;SAC3E,CAAC;QAEF,qBAAe,GAAG,UACd,IAAoB,EACpB,QAA0C;YAE1C,OAAO,KAAI,CAAC,aAAa,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI;gBAC/C,IAAI;qBACD,KAAI,CAAC,eAAe,CAAC,CAAC,EAAE,QAAQ,CAAC,IACvC,CAAC,CAAC;SACN,CAAC;QAEF,qBAAe,GAAG,UACd,UAA0B,EAC1B,QAA0C;YAE1C,IAAM,MAAM,GAAqB,EAAE,CAAC;YACpC,OAAO,UAAU,CAAC,QAAQ,EAAE;gBACxB,KAAI,CAAC,wBAAwB,CAAC,UAAU,CAAC,CAAC;gBAC1C,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;gBACxB,UAAU,GAAG,QAAQ,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;aACtD;YACD,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YACxB,OAAO,MAAM,CAAC;SACjB,CAAC;QAWF,mBAAa,GAAG,UACZ,IAAoB,EACpB,QAA0C,IACvB,OAAA,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,UAAA,EAAE,IAAI,OAAA,QAAQ,CAAC,EAAE,CAAC,GAAA,CAAC,GAAA,CAAC;;KAmMrE;IAhVG,mCAAW,GAAX,UACI,QAAgB,EAChB,OAAe,EACf,MAAwB;QAH5B,iBAyBC;QApBG,OAAO,MAAM;aACR,MAAM,CAAC,UAAC,CAAC,EAAE,CAAC;YACT,OAAO,CAAC,GAAG,CAAC,KAAK,MAAM,CAAC,MAAM,CAAC;SAClC,CAAC;aACD,MAAM,CAAC,UAAC,MAAkB,EAAE,IAAI,EAAE,CAAC;YAChC,IAAM,QAAQ,GAAG,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAC/B,IAAM,IAAI,GAAG,KAAI,CAAC,eAAe,CAC7B,QAAQ,EACR,OAAO,EACP,IAAI,EACJ,QAAQ,CACX,CAAC;YACI,IAAA,cAA4B,EAA3B,UAAE,EAAE,UAAE,EAAE,UAAE,EAAE,UAAE,CAAc;YACnC,IAAI,CAAC,KAAK,CAAC,EAAE;gBACT,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;aACnC;iBAAM;gBACH,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;aACzB;YACD,OAAO,MAAM,CAAC;SACjB,EAAE,EAAE,CAAC,CAAC;KACd;IACD,uCAAe,GAAf,UACI,QAAgB,EAChB,OAAe,EACf,IAAoB,EACpB,MAAsB;QAEtB,IAAM,OAAO,GAAG,cAAc,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QAC7C,IAAM,SAAS,GAAG,kBAAkB,CAChC,IAAI,CAAC,CAAC,EACN,IAAI,CAAC,CAAC,EACN,MAAM,CAAC,CAAC,EACR,MAAM,CAAC,CAAC,CACX,CAAC;QACI,IAAA,iCAAyC,EAAxC,YAAI,EAAE,UAAE,CAAiC;QACzC,IAAA,uBAAU,EAAE,yBAAY,CAAY;QACrC,IAAA,oEAML,EANM,UAAE,EAAE,UAAE,CAMX;QACI,IAAA,sEAML,EANM,UAAE,EAAE,UAAE,CAMX;QACF,OAAO;YACH,IAAI,MAAA;YACJ,MAAM,QAAA;YACN,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;SACzB,CAAC;KACL;IAED,gCAAQ,GAAR,UACI,QAAgB,EAChB,OAAe,EACf,IAAoB,EACpB,QAA0C;QAJ9C,iBAYC;QANG,IAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QACtD,OAAO,QAAQ,CAAC,GAAG,CAAC,UAAA,MAAM,IAAI,QAAC;YAC3B,IAAI,EAAE,IAAI;YACV,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;YACjC,IAAI,EAAE,KAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,OAAO,EAAE,MAAM,CAAC;SACpD,IAAC,CAAC,CAAC;KACP;IAED,iCAAS,GAAT,UACI,QAAgB,EAChB,OAAe,EACf,IAAoB;QAEpB,OAAO,CAAC,IAAI,CAAC,CAAC,GAAG,QAAQ,GAAG,OAAO,EAAE,IAAI,CAAC,CAAC,GAAG,QAAQ,GAAG,OAAO,CAAC,CAAC;KACrE;IAED,+BAAO,GAAP,UAAQ,QAAgB,EAAE,OAAe;QACrC,OAAO,QAAQ,GAAG,OAAO,GAAG,CAAC,CAAC;KACjC;IA2CD,gDAAwB,GAAxB,UAAyB,IAAoB;QACzC,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,IAAI,CAAC;YAC9B,MAAM,IAAI,KAAK,CACX,8BACI,IAAI,CAAC,EAAE,kBACE,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,CAAG,CAC9C,CAAC;KACT;IAOD,uCAAe,GAAf,UACI,IAAoB,EACpB,MAAsB;QAEhB,IAAA,eAAgE,EAA9D,4BAAW,EAAE,sCAAgB,EAAE,sCAAgB,CAAgB;QACvE,IAAM,QAAQ,GAEV,EAAE,CAAC;QACP,IAAI,WAAW;YACX,QAAQ,CAAC,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC,WAAW,EAAE,IAAI,EAAE;gBACxD,MAAM;aACT,CAAC,CAAC;QACP,IAAI,gBAAgB;YAChB,QAAQ,CAAC,YAAY,GAAG,IAAI,CAAC,gBAAgB,CACzC,gBAAgB,EAChB,IAAI,EACJ,CAAC,MAAM,CAAC,CACX,CAAC;QACN,IAAI,gBAAgB;YAChB,QAAQ,CAAC,YAAY,GAAG,IAAI,CAAC,gBAAgB,CACzC,gBAAgB,EAChB,IAAI,EACJ,CAAC,MAAM,CAAC,CACX,CAAC;QACN,OAAO,QAAQ,CAAC;KACnB;IAED,iCAAS,GAAT,UAAU,UAAkB,EAAE,QAAgB;QAC1C,IAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;QACxD,OAAO,QAAQ,GAAG,EAAE,SAAS,EAAE,UAAQ,QAAQ,MAAG,EAAE,GAAG,EAAE,CAAC;KAC7D;IAED,mCAAW,GAAX,UAAY,UAAkB,EAAE,QAAgB;QACpC,IAAA,sBAAI,CAAgB;QAC5B,OAAU,UAAU,SAAI,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,SAAI,QAAQ,CAAC,IAAI,EAAI,CAAC;KAC/D;IAED,yCAAiB,GAAjB,UAAkB,MAAsB;QAC9B,IAAA,eAAoD,EAAlD,cAAI,EAAS,eAAE,EAAG,sBAAQ,EAAE,oBAAO,CAAgB;QAC3D,IAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,KAAK,EAAE,GAAA,CAAC,CAAC;QAEnD,IAAA,4CAAmD,EAAhD,aAAK,CAA4C;QACpD,IAAA,8CAAwD,EAAvD,SAAC,EAAE,eAAO,CAA8C;QAE/D,IAAI,CAAC,GAAG,KAAK,CAAC;QACd,IAAI,OAAO,GAAG,KAAK,EAAE;YACjB,CAAC,GAAG,OAAO,CAAC;SACf;QACD,IAAI,OAAO,KAAK,KAAK,EAAE;YACnB,CAAC,GAAG,CAAC,GAAG,QAAQ,GAAG,KAAK,CAAC;SAC5B;QAED,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;KACjB;IAED,8CAAsB,GAAtB,UAAuB,MAAsB;QACnC,IAAA,eAAoD,EAAlD,cAAI,EAAS,eAAE,EAAG,sBAAQ,EAAE,oBAAO,CAAgB;QAC3D,IAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,KAAK,EAAE,GAAA,CAAC,CAAC;QAEnD,IAAA,4CAAwD,EAAvD,aAAK,EAAE,aAAK,CAA4C;QACzD,IAAA,8CAA8D,EAA7D,eAAO,EAAE,eAAO,CAA8C;QAErE,IAAM,CAAC,GAAG,OAAO,GAAC,CAAC,GAAG,KAAK,GAAC,CAAC,CAAC;QAE9B,IAAI,CAAC,GAAG,KAAK,CAAC;QACd,IAAI,OAAO,GAAG,KAAK,EAAE;YACjB,CAAC,GAAG,OAAO,CAAC;SACf;QACD,IAAI,OAAO,KAAK,KAAK,EAAE;YACnB,CAAC,GAAG,CAAC,GAAG,QAAQ,GAAG,KAAK,CAAC;SAC5B;QAED,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;KACjB;IAED,qCAAa,GAAb,UAAc,MAAsB;QAC1B,IAAA,eAAiD,EAA/C,sBAAQ,EAAE,oBAAO,EAAE,gCAAa,CAAgB;QAClD,IAAA,wCAA4C,EAA3C,SAAC,EAAE,SAAC,CAAwC;QACnD,IAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAE7C,IAAI,CAAC,aAAa,EAAE;YAChB,OAAO,IAAI,CAAC;SACf;QAED,IAAM,SAAS,GAAG,aAAa,CAAC;QAChC,QACIC,uCACI,SAAS,EAAC,WAAW,EACrB,CAAC,EAAE,CAAC,GAAG,IAAI,GAAG,GAAG,GAAG,QAAQ,GAAG,GAAG,EAClC,CAAC,EAAE,CAAC,GAAG,IAAI,GAAG,GAAG,GAAG,QAAQ,GAAG,GAAG,EAClC,KAAK,EAAE,QAAQ,GAAG,GAAG,EACrB,MAAM,EAAE,QAAQ,GAAG,GAAG,EACtB,KAAK,EAAE,EAAE,OAAO,EAAE,MAAM,EAAE;YAE1BA,oBAAC,SAAS,OAAG,CACD,EAClB;KACL;IAED,gCAAQ,GAAR,UAAS,MAAsB;QACrB,IAAA,eAA8C,EAArC,eAAE,EAAG,sBAAQ,EAAE,oBAAO,CAAgB;QAC7C,IAAA,kBAAI,EAAE,qBAAc,EAAd,mCAAc,CAAY;QAElC,IAAA,mCAA+C,EAA9C,aAAK,EAAE,aAAK,CAAmC;QAChD,IAAA,wCAAwD,EAAvD,eAAO,EAAE,eAAO,CAAwC;QAC/D,IAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAC7C,IAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,KAAK,EAAE,GAAA,CAAC,CAAC;QAClD,QACIA;YACIA,gCACI,EAAE,EAAE,OAAO,GAAG,IAAI,GAAG,GAAG,EACxB,EAAE,EAAE,OAAO,GAAG,IAAI,GAAG,GAAG,EACxB,CAAC,EAAE,QAAQ,GAAG,IAAI,EAClB,KAAK,EAAE;oBACH,MAAM,EAAE,MAAM;oBACd,IAAI,EAAE,KAAK;oBACX,OAAO,EAAE,IAAI;iBAChB,GACH;YACD,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,KACfA,8BACI,CAAC,EAAE,KAAK,GAAG,IAAI,GAAG,GAAG,EACrB,CAAC,EAAE,KAAK,GAAG,IAAI,GAAG,GAAG,EACrB,UAAU,EAAC,QAAQ,EACnB,gBAAgB,EAAC,QAAQ,EACzB,KAAK,EAAE;oBACH,MAAM,EAAE,MAAM;oBACd,WAAW,EAAE,CAAC;oBACd,IAAI,EAAE,SAAS;oBACf,UAAU,EAAE,QAAQ;iBACvB,IAEA,SAAS,CAAC,KAAK,CAAC,CACd,CACV,CACF,EACN;KACJ;IAED,qCAAa,GAAb,UAAc,IAAmB;QAC7B,OAAO,IAAI,CAAC,IAAI;aACX,GAAG,CAAC,UAAA,KAAK,IAAI,OAAA,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,GAAA,CAAC;aAC7B,OAAO,EAAE;aACT,IAAI,CAAC,GAAG,CAAC,CAAC;KAClB;IAED,mCAAW,GAAX,UAAY,IAAoB,EAAE,KAAsB;QAAxD,iBAoCC;QAnCG,IAAM,UAAU,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC;QACvC,OAAO,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,QACrBA,oCACI,GAAG,EAAE,UAAQ,IAAI,CAAC,EAAE,SAAI,IAAI,CAAC,MAAM,CAAC,EAAI,IACpC,KAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,IAChD,KAAK,EAAE;gBACH,WAAW,EAAE,CAAC;gBACd,IAAI,EAAE,SAAS;gBACf,MAAM,EAAE,SAAS;aACpB;YAEA,KAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC;YAC3BA,oBAAC,aAAa,IACV,EAAE,EAAE,KAAI,CAAC,WAAW,CAAC,UAAU,EAAE,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,EAChD,KAAK,EAAE,EAAE,EACT,MAAM,EAAE,EAAE,GACZ;YACFA,kCACI,IAAI,EAAE,MAAM,EACZ,SAAS,EAAC,WAAW,EACrB,MAAM,EAAE,KAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EAChC,KAAK,EAAE;oBACH,WAAW,EAAE,CAAC;oBACd,MAAM,EAAE,SAAS;iBACpB,GACH;YACFA,6CACQ,KAAI,CAAC,SAAS,CAAC,UAAU,EAAE,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,IAC9C,IAAI,EAAE,MAAM,EACZ,SAAS,EAAC,WAAW,EACrB,MAAM,EAAE,KAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAClC;YACD,KAAI,CAAC,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,CAChC,IACP,CAAC,CAAC;KACN;IAED,8BAAM,GAAN;QACU,IAAA,eAAkD,EAAhD,cAAI,EAAE,sBAAQ,EAAE,sBAAQ,EAAE,oBAAO,CAAgB;QACzD,IAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;QAC/D,QACI,KAAK,CAAC,MAAM,KACRA,2BAAG,SAAS,EAAC,YAAY,IAAE,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,KAAK,CAAC,CAAK,CAChE,EACH;KACL;IACL,oBAAC;CAAA,CAnVqCC,eAAe,GAmVpD;;ACzXD;IAA8BF,yBAAwC;IAAtE;QAAA,qEAmDC;QAlDG,0BAAoB,GAAG,UAAC,QAA0C;YAC9D,OAAO,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;iBAC1B,MAAM,CAAC,UAAC,EAAS;oBAAR,SAAC,EAAE,YAAI;gBAAM,OAAA,CAAC,IAAI,CAAC,QAAQ;aAAA,CAAC;iBACrC,GAAG,CAAC,UAAC,EAAS;oBAAR,SAAC,EAAE,YAAI;gBAAM,QAAC;oBACjB,IAAI,MAAA;iBACP;aAAC,CAAC,CAAC;SACX,CAAC;;KA4CL;IA3CG,8BAAc,GAAd;QACI,IAAM,eAAuF,EAArF,sBAAQ,EAAE,sBAAQ,EAAE,oBAAO,EAAE,8BAAY,EAAE,gCAAa,EAAE,4FAA2B,CAAC;QAC9F,IAAM,QAAQ,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;QACrD,QACIC;YACK,QAAQ,CAAC,GAAG,CAAC,UAAA,KAAK,IAAI,QACnBA,oBAAC,aAAa,aACV,GAAG,EAAE,eAAa,KAAK,CAAC,IAAI,CAAC,EAAI,EACjC,QAAQ,EAAE,QAAQ,EAClB,OAAO,EAAE,OAAO,EAChB,QAAQ,EAAE,QAAQ,IACd,KAAK,EACL,SAAS,EACf,IACL,CAAC;YACD,QAAQ,CAAC,GAAG,CAAC,UAAA,KAAK,IAAI,QACnBA,oBAAC,YAAY,aACT,GAAG,EAAE,cAAY,KAAK,CAAC,IAAI,CAAC,EAAI,EAChC,QAAQ,EAAE,QAAQ,EAClB,OAAO,EAAE,OAAO,EAChB,QAAQ,EAAE,QAAQ,IACd,KAAK,EACL,SAAS,EACf,IACL,CAAC,CACH,EACN;KACJ;IACD,sBAAM,GAAN;QACU,IAAA,eAAsD,EAApD,sBAAQ,EAAE,8BAAY,EAAE,gCAAa,CAAgB;QAC7D,QACIA,6BACI,KAAK,EAAC,4BAA4B,EAClC,UAAU,EAAC,8BAA8B,EACzC,OAAO,EAAC,GAAG,EACX,KAAK,EAAE,YAAY,GAAG,QAAQ,EAC9B,MAAM,EAAE,aAAa,GAAG,QAAQ;YAEhCA,oBAAC,iBAAiB,OAAG;YACpB,IAAI,CAAC,cAAc,EAAE,CACpB,EACR;KACL;IACL,YAAC;CAAA,CAnD6BC,eAAe,GAmD5C;;;;;ACvED;;;AAuBA;IAA4CF,+BAA8B;IAA1E;QAAA,qEAiBC;QAhBG,iBAAW,GAAG,UAAC,IAAqB;YAChC,IAAM,KAAK,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC;YAC9B,IAAM,GAAG,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC;YAC7B,OAAO;gBACH,QAAQ,EAAE,GAAG,CAAC,SAAS,EAAE;gBACzB,YAAY,EAAE,GAAG,CAAC,KAAK;gBACvB,aAAa,EAAE,GAAG,CAAC,MAAM;aAC5B,CAAC;SACL,CAAC;;KAQL;IANG,4BAAM,GAAN;QACI,IAAM,eAAmC,EAAjC,cAAI,EAAE,gCAA2B,CAAC;QAC1C,IAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAEzC,OAAOC,oBAACG,OAAS,eAAK,SAAS,EAAM,SAAS,EAAI,CAAC;KACtD;IACL,kBAAC;CAAA,CAjB2CF,eAAe,GAiB1D;;;;;"}